
Docker: is a containerization platform. 

Deployment modes:
1) VM Machine
2) Containerisation platform.

VM Architecture:
VM Server -> Host OS -> Hypervisor (Type 1,2) -> Guest OS (can be multiple) -> Applications (A, B, C .... can be multiple)
                                                       |------------------- VM ----------------|  

Oracle Virtual box is an example of hypervisor.
													   
so in VM, there are 2 OS i.e. Host OS and Guest OS and each Guest OS occupies its own set of resources which are not shared by other Guest OS.
so VM size is more than Container
Time taken by VM is more than container.
VM if integrated with devops tool is inefficient as compared to container.
Container takes less time to start while VM takes more time to start.

In case of docker:
Server -> Host OS -> Docker Engine -> Applications ( A, A', B, B' ..... ) as containers 

so the same kernel (or resources) is shared by multiple applications.

container is a package containing application binaries and resources (libraries, dependencies, network, storage). Thus the application can work in different environments.

A container can be created on virtual machine, public cloud, hardware.

Docker Architecture: is a client server architecture.
A docker binary contains client and server components. 
- Clients is responsible for directing servers what to do. 
- Servers host containerised applications.

Client (i.e Host machine or cli where you have docker engine) -> runs Docker Host which has docker daemon which accepts command coming from client CLI and performs operation.
example

Client CLI           Docker Daemon
docker Build			will check if image is present and then pull image from docker registry.
						will pull the image from Docker registry (i.e. public registry like github comprising of pre-defined images)
docker pull
docker push				
docker run

Image: static entity which can create multiple containers.

 
Kubernetes: is an orchrestration tool.
i.e. for a production like environment which may contain a lot of containers, orcrestation tool helps manage the containers and life cycle of containers.
can be used for resource mgmt, scheduling containers, restart containers, creating new containers, scale up/down containers.

Both Docker and Kubernetes are different things.

Before kubernetes (i.e. limitation if just using containers),
containers cannot communicate with each other.
containers must be deployed appropriately. Monitoring is necessary.
containers must be managed properly.
autoscaling is not available.
distributing traffic was challenging. 

with Kubernetes, all these are possible.

Kubernetes is originated from a google containerization concept called BROG. K is written in GO language.

Features
fail safe: if any node on server is failed, it will automatically start server on different nodes. Ensure if container is failed, it will be restarted.
self healing: if any container fails, it restarts on its own. No manual restart required. It will create a new container for crashed container. 
Horizontal/Auto scaling : based on usage, one can increase/decrease the number of containers running. It can be based on CPU Usage. This can be done by CLI or GUI.
Storage orchestration : K mounts the storage volume.
service discovery: K manages networking by assigning IPs/hostnames to PODs (i.e. group of container)
Automatic rollouts and rollbacks: 
config management: one does not have to recreate the container if one has to implement any configurations.
batch execution: K can manage batch.

Kubernetes Cluster Architecture:

Master -----------> Minion [ Docker [ POD [ Container ] POD2 [ Containers ] POD3 [ Containers ] ] ]
 |----------------> Minion [ Docker [ POD [ Container ] POD2 [ Containers ] POD3 [ Containers ] ] ]
 |----------------> Minion [ Docker [ POD [ Container ] POD2 [ Containers ] POD3 [ Containers ] ] ]

i.e. Master is one node which controls/assigns tasks on multiple minions. In Master node we can run commands to know the number of minions or pods.
     Minion is worker node which run tasks delegated by master on multiple pods.
	 Pods are logical collection of containers that belong to an application. These are deployable units which can be created and scheduled.
	    A Pod can have one container or multiple applications. Applications are deployed on pod i.e. all application containers as a pod.
		Pod can run single instance of an application.
		
POD Networking:
each pod has its own IP address and pods can inter-communicate with other pods using IP address. 
     
Components of Master:

Master ---------------> Replication Controller ( API ensures the requested number of pods are running on minions at all times. If a pod fails, RC will restart
                                                 it. If a node fails, all the pods will be restarted on a different node.  ) 
  |------------------->	Service (  A pod comprising of an application is not by default available to end-user. To make application available, the pod has to be 
                                   exported as a service. Service is an object comprising of logical set of pods on an external IP accessible to user )
  |-------------------> Label ( Key/Value pair that is used for deployment. Each POD is labelled depending upon application deployed in it. i.e. Pods having
                                one task are assigned a label, A selector will select a label for a particular task)
  
Minion ---------------> Kuberlet ( manages the PODs present within the minion. Kuberlet ensures that the pods are started and continue running,
                                   Kuberlet reads the containers as YAML* file. It has Docker client, root directory, Pod Workers, Etcd client, CAdvisor client ) 

YAML is a config file used by K which follows a format that describes the object, apiVersion, metadata of the object, specification of the containers.
using YAML file (i.e. .yml) one can create single or multiple container POD.

to create a POD : kubectl create -f <filename.yaml>
to view all the POD: kubectl get pods
								   
So,
NODE (IP 172.17.8.102) -> Service (this service will use LABEL L1, Domain-name Service-1, IP 10.2.10.20, Port 9443, Node Port 32001 ) -> POD-1,2,3 (All assigned LABEL as L1 and Port: 9443) 								   
								   
Detailed Kubernetes Architecture:

Developer -> Kubernetes Master ( API Server (all commands are interpreted by API Server) --> Controller Manager
                                 |    |--------> Scheduler (finds suitable node to run a container in particular pod)    
								 |    |--------> ETCD (persistent storage used by K to store node information in key-value format)
                                 |
                    ------<------ --------->------
                    |							 |
                Kubernetes Node	<--------------> Kubernetes Node
    Kuberlet CAdvisor Kube-Proxy                 Kube-Proxy CAdvisor Kuberlet
    POD POD POD .....	|						 	|		POD POD POD .....
	                    |                           |
						-----------------------------
						             |
                                    End User

Kuberlet: responsible for managing life-cycle of a container and a POD.
kube proxy : manages the network to make the containers available to external application.
cAdvisor : agent which monitors the memory and CPU usage.
									
									
NOTE: All kubernetes nodes (i.e. worker nodes) are connected by plugin network like ( ex Falnnel, Weavernet ). Flannel is used by-default.
									
	
-----------------------------------------
Kubernetes vs docker swarm
K has GUI for scaling up/down containers ; DS does not have GUI
K is difficult to install ; DS is easier.
K load balancing is manual but reliable ; DS has built in load balancing.
K has inbuilt logging/monitoring tool for container state; DS needs 3rd party tool for logging/monitoring.
K has a huge online presence/help.