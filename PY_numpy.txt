NumPy stands for Numerical Python is a library consisting of multidimensional array objecs and functions to process them

NumPy is often used along with packages like SciPy (Scientific Python) and Mat-plotlib (plotting library) for technical computing (Matlab can also be used for same)

Using NumPy, a developer can perform the following operations -
a) Mathematical and logical operations on arrays.
b) Fourier transforms and routines for shape manipulation.
c) Operations related to linear algebra. NumPy has in-built functions for linear algebra and random number generation.

Note: Standard Python distribution doesn't come bundled with NumPy module. A lightweight alternative is to install NumPy using popular Python package installer, pip.
      pip install numpy
	  
----------------------------
ndarray: N-dimensional array is array of items of the same type.Items in the collection can be accessed using a zero-based index.
         Each element in ndarray is an object of data-type object (called dtype).
		 ndarrays are usually of fixed size and can be multidimensional. 
		 
		 In a NumPy array, the number of dimensions is called the rank, and each dimension is called an axis. 
		 So the rows are the first axis, and the columns are the second axis.
		 
		 NOTE: One of the limitations of NumPy is that all the elements in an array have to be of the same type
		 
The basic ndarray is created using,
1) numpy.array.
	example-1,
	import numpy as np 
	a = np.array([1,2,3]) 
	print a  //o/p: [1, 2, 3]
	
	example-2,
	import numpy as np 
	a = np.array([[1, 2], [3, 4]]) 
	print a  
	
	//o/p: [[1, 2] 
			[3, 4]]
			
2) numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)
	where,
	a) object: any sequence or nested sequence
	b) dtype: desired data type of the array. THIS IS OPTIONAL
	c) copy: for copying the object. By default, it is "True". ALSO OPTIONAL
	d) order: has 3 values, A -> any (DEFAULT), C -> row major, F -> column major
	e) subok
	f) ndmin: specifies minimum dimensions of the resultant array.
	
	example-1,
		import numpy as np 
		a = np.array([1, 2, 3,4,5], ndmin = 2) 
		print a
		
		o/p:
		[[1, 2, 3, 4, 5]]
	
	example-2,
		import numpy as np 
		a = np.array([1, 2, 3], dtype = complex) 
		print a
		
		o/p:
		[ 1.+0.j,  2.+0.j,  3.+0.j]


the number of dimensions and items in an array is defined by its shape, which is a tuple of N positive integers that specify the sizes of each dimension. example,
//A 2-dimensional array of size 2 x 3, composed of 4-byte integer elements
x = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
type(x)  //o/p: <type 'numpy.ndarray'>

x.shape  //o/p: (2, 3)

x.dtype  //o/p: dtype('int32')

-----------------------------------------
Data Types:

NumPy stores values using its own data types, which are distinct from Python types like float and str. 
This is because the core of NumPy is written in a programming language called C, which stores data differently than the Python data types. 
NumPy data types map between Python and C, allowing us to use NumPy arrays without any conversion hitches.

bool_    : for boolean
int8     : Byte (-128 to 127)
int16    : Integer (-32768 to 32767)
int32    : Integer (-2147483648 to 2147483647)
int64    : Integer (-9223372036854775808 to 9223372036854775807)
uint8    : Unsigned integer (0 to 255)
uint16   : Unsigned integer (0 to 65535)
uint32   : Unsigned integer (0 to 4294967295)
uint64   : Unsigned integer (0 to 18446744073709551615)
float16  : Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
float32  : Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
float64  : Double precision float
complex64: two 32-bit floats 
complex128: two 64-bit floats
int_      : default integer type. used for int32 or int64
float_    : Shorthand for float64

dtype: i.e data type object
dtype are arrays which can have combinations of fundamental data types. This is different from numpy arrays as numpy arrays only store fundamental numeric data types (int and float).

dtype allows us to create structured arrays (i.e. "record arrays")
example, 
Country			Population Density		Area		Population
Netherlands 	393 					41526 		16,928,800 
Belgium 		337 					30510 		11,007,020 
United Kingdom 	256 					243610 		62,262,000 

example of dtype,
	import numpy as np
	i16 = np.dtype(np.int16)			//We define an int16 
	print(i16)
	lst = [ [3.4, 8.7, 9.9], 
			[1.1, -7.8, -0.7],
			[4.1, 12.3, 4.8] ]
	A = np.array(lst, dtype=i16)       //The elements of the list 'lst' are turned into i16 types to create the two-dimensional array A.
	print(A)
	
	o/p:
	int16
	[[ 3  8  9]
	 [ 1 -7  0]
	 [ 4 12  4]]

A dtype object is constructed using the following syntax -
numpy.dtype(object, align, copy)
where,
	Object - To be converted to data type object
	Align  - If true, adds padding to the field to make it similar to C-struct
	Copy   - Makes a new copy of dtype object. If false, the result is reference to builtin data type object

built in data type short hand,
'b' - boolean
'i' - (signed) integer
'u' - unsigned integer
'f' - floating-point
'c' - complex-floating point
'm' - timedelta
'M' - datetime
'O' - (Python) objects
'S', 'a' - (byte-)string
'U' - Unicode
'V' - raw data (void)

creating structured arrays via datatype,
reconsider the example using,
Country			Population Density		Area		Population
Netherlands 	393 					41526 		16,928,800 
Belgium 		337 					30510 		11,007,020 
United Kingdom 	256 					243610 		62,262,000 

import numpy as np
dt = np.dtype([('density', np.int32)])
x = np.array([(393,), (337,), (256,)],dtype=dt)
print(x) 
print("\nThe internal representation:")
print(repr(x))
print(x['density'])    //access the content of density column.

o/p,
[(393,) (337,) (256,)]
The internal representation:
array([(393,), (337,), (256,)],
      dtype=[('density', '<i4')])
[393 337 256]

same example with data type short hand,
dt = np.dtype([('density', 'i4')])       //here, The 'i' means integer and the 4 means 4 bytes
x = np.array([(393,), (337,), (256,)],
             dtype=dt)
print(x)                                 //o/p: [(393,) (337,) (256,)]


What is less-than sign in front of i4 in the result?
'<' - means that the encoding will be little-endian.
'>' - means that the encoding will be big-endian.
no Prefix - native byte ordering.

example,
# little-endian ordering
dt = np.dtype('<d')
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 = 8
# big-endian ordering
dt = np.dtype('>d')  
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 > 8
# native byte ordering
dt = np.dtype('d') 
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 = 8

example, (to define the entire dataset)
dt = np.dtype([('country', 'S20'), ('density', 'i4'), ('area', 'i4'), ('population', 'i4')])
population_table = np.array([
    ('Netherlands', 393, 41526, 16928800),
    ('Belgium', 337, 30510, 11007020),
    ('United Kingdom', 256, 243610, 62262000)],dtype = dt)
print ( population_table )
print ("\n")
print ( population_table[:1])
print(population_table['density'])
print(population_table['country'])
print(population_table['area'][:2])

o/p:
[(b'Netherlands', 393,  41526, 16928800)
 (b'Belgium', 337,  30510, 11007020)
 (b'United Kingdom', 256, 243610, 62262000)]
 
[(b'Netherlands', 393,  41526, 16928800)]

[393 337 256]
[b'Netherlands' b'Belgium' b'United Kingdom']
[41526,30510]


Datatype explicit convesion:
numpy.ndarray.astype is used for explicit conversion.
example, 
wines.astype(int)

dt = np.dtype([('density', np.float32)])
x = np.array([(393,), (337,), (256,)],dtype=dt)
print(x['density'])    //access the content of density column.
int_x = x.astype(int32)
print (int_x['density'])

o/p,
[393.0 337.0 256.0]
[393 337 256]

-------------------------------------------------------------
Array Attributes:
1) ndarray.shape: returns a tuple consisting of array dimensions
	example,
		import numpy as np 
		a = np.array([[1,2,3],[4,5,6]]) 
		print (a.shape)                     //re-sizes the ndarray 
		b = np.array([[1,2,3],[4,5,6]])
		b.shape = (3,2)
		print (b)
		c = a.reshape(3,2)               //re-size function to resize an array. 
		print (c)
		
	o/p:
	(2, 3)
	[[1, 2] 
	 [3, 4] 
	 [5, 6]]
	[[1, 2] 
	 [3, 4] 
	 [5, 6]]
	 
2) arange: returns an array with predefined range.
	example,
		import numpy as np 
		a = np.arange(24)     //Note: the range will start with 0 
		print (a)
		b = a.reshape(2,4,3)  //3 dimensional array
		print (b)
		
		
	o/p: 
	[0 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16 17 18 19 20 21 22 23]
	[[[ 0,  1,  2] 
	  [ 3,  4,  5] 
	  [ 6,  7,  8] 
	  [ 9, 10, 11]]  
	  [[12, 13, 14] 
	   [15, 16, 17]
	   [18, 19, 20] 
    [21, 22, 23]]] 
	
3) ndarray.ndim: returns the number of array dimensions.
	example,
		import numpy as np 
		a = np.arange(24)     //Note: the range will start with 0 
		print (a.ndim)
		b = a.reshape(2,4,3)  //3 dimensional array
		print (b.ndim)
		
	o/p:
	1
	3

4) numpy.itemsize: returns the length of each element of array in bytes.
	example,
		# dtype of array is int8 (1 byte) , float32 (4 bytes)
		import numpy as np 
		x = np.array([1,2,3,4,5], dtype = np.int8) 
		print x.itemsize
		y = np.array([1,2,3,4,5], dtype = np.float32)
		print y.itemsize
		
	o/p: 
	1
	4
	
---------------------------------------------------------------------
Array Creation Routines:
A new ndarray object can be created and initialized via,
1) numpy.empty: creates an uninitialized array of specified shape and dtype
	Syntax: numpy.empty(shape, dtype = float, order = 'C')
			where Order -> 'C' for C-style row-major array, 'F' for FORTRAN style column-major array.
			
	example,
	import numpy as np 
	x = np.empty([3,2], dtype = int) 
	print x

	o/p, will be random values as,
	[[22649312    1701344351] 
	 [1818321759  1885959276] 
	 [16779776    156368896]]
	 
2) numpy.zeros: creates a new array of specified size, filled with zeroes.

	example1,
	# array of five zeros. Default dtype is float 
	import numpy as np 
	x = np.zeros(5) 
	print x
	
	o/p, [ 0.  0.  0.  0.  0.]
	
	example2,
	# custom type 
	import numpy as np 
	x = np.zeros((2,2), dtype = [('x', 'i4'), ('y', 'i4')])  
	print x
	
	o/p:
	[[(0,0)(0,0)]
	[(0,0)(0,0)]] 
	
3) numpy.ones: similar to numpy.zeroes except arrays are filled with ones.
------------------------------------------------------------
Array From Existing Data (ex, array, tuples etc)

1) numpy.asarray: 
	example 1,
		import numpy as np 
		x = [1,2,3] 
		a = np.asarray(x) 
		print a
		
	o/p: [1  2  3]
	
	example 2,
		import numpy as np 
		x = [1,2,3]
		a = np.asarray(x, dtype = float) 
		print a
		
	o/p: [ 1.  2.  3.] 
	
	example 3,
		import numpy as np 
		x = (1,2,3) 
		a = np.asarray(x) 
		print a
		
	o/p: [1  2  3]
	
2) numpy.frombuffer: interprets a buffer as one-dimensional array.
	syntax: numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)
			where,
			count : The number of items to read, default -1 means all data
			offset: The starting position to read from. Default is 0
			
	example,
		import numpy as np 
		s = 'Hello World' 
		a = np.frombuffer(s, dtype = 'S1') 
		print a
	
	o/p: ['H'  'e'  'l'  'l'  'o'  ' '  'W'  'o'  'r'  'l'  'd']
	
	
3) numpy.fromiter: This function builds a new ndarray object from any iterable object.
	example,
		import numpy as np 
		list = range(5) 
		it = iter(list)  
		# use iterator to create ndarray 
		x = np.fromiter(it, dtype = float) 
		print x

	o/p: [0.   1.   2.   3.   4.]
	
4) numpy.arange: create an array from numerical ranges.
	syntax, numpy.arange(start, stop, step, dtype)
			where,
			start -> The start of an interval. If omitted, defaults to 0
			stop  -> The end of an interval (not including this number)
			step  -> Spacing between values, default is 1
			
	example,
		import numpy as np
		x = np.arange(5) 
		print x
		y = np.arange(5, dtype = float)
		print y
		z = np.arange(10,20,2) 
		print z

	o/p:
	[0  1  2  3  4]
	[0.  1.  2.  3.  4.] 
	[10  12  14  16  18]
	
---------------------------------------------------------------------------
Indexing & Slicing:

used to access and modify ndarrays. There are three types of indexing methods are available - 
field access 
basic slicing
advanced indexing.

example 1,
	import numpy as np 
	a = np.arange(10) 
	s = slice(2,7,2)    //i.e. start, stop, and step 
	print a[s]
	b = a[2:7:2] 
	print b
	c = a[5] 
	print c
	print a[2:]
	print a[2:5]
	z = np.array([[1,2,3],[3,4,5],[4,5,6]]) 
	print a
	print 'Now we will slice the array from the index a[1:]' 
	print a[1:]
	
	o/p: 
	[2  4  6]
	[2  4  6]
	5
	[2  3  4  5  6  7  8  9]
	[2  3  4]
	[[1 2 3]
	 [3 4 5]
	 [4 5 6]]
	Now we will slice the array from the index a[1:]
	[[3 4 5]
	 [4 5 6]]
	
example 2,
	# array to begin with 
	import numpy as np 
	a = np.array([[1,2,3],[3,4,5],[4,5,6]]) 

	print 'Our array is:' 
	print a 
	print '\n'  

	# this returns array of items in the second column 
	print 'The items in the second column are:'  
	print a[...,1] 
	print '\n'  

	# Now we will slice all items from the second row 
	print 'The items in the second row are:' 
	print a[1,...] 
	print '\n'  

	# Now we will slice all items from column 1 onwards 
	print 'The items column 1 onwards are:' 
	print a[...,1:]
	
	o/p:
	Our array is:
	[[1 2 3]
	 [3 4 5]
	 [4 5 6]] 
	 
	The items in the second column are: 
	[2 4 5] 

	The items in the second row are:
	[3 4 5]

	The items column 1 onwards are:
	[[2 3]
	 [4 5]
	 [5 6]] 

	 
Integer Indexing,
you can select any arbitrary item in an array based on its Ndimensional index.
example 1,
	import numpy as np 
	x = np.array([[1, 2], [3, 4], [5, 6]]) 
	y = x[[0,1,2], [0,1,0]] 		//includes elements at (0,0), (1,1) and (2,0) from x	
	print y

	o/p: [1  4  5]
	
example 2, will give the corner values [COULD NOT UNDERSTAND THIS EXAMPLE]
	import numpy as np 
	x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
	print 'Our array is:' 
	print x 
	print '\n' 
	rows = np.array([[0,0],[3,3]])    //[[ 9 10 11]  [ 9 10 11]]]
	cols = np.array([[0,2],[0,2]])    //[[[0 1 2]  [6 7 8]] [[0 1 2]  [6 7 8]]]
	y = x[rows,cols] 
	print 'The corner elements of this array are:' 
	print y

	o/p,
	Our array is:                                                                 
	[[ 0  1  2]                                                                   
	 [ 3  4  5]                                                                   
	 [ 6  7  8]                                                                   
	 [ 9 10 11]]
	 
	The corner elements of this array are:                                        
	[[ 0  2]                                                                      
	 [ 9 11]] 
	 
	 
Slicing an array:
example,
	import numpy as np 
	x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
	print 'Our array is:' 
	print x 
	print '\n'  
	# slicing 
	z = x[1:4,1:3]     //AS IT WILL IGNORE THE LAST ELEMENT, i.e. it will consider 1:3,1:2
	print 'After slicing, our array becomes:' 
	print z 
	print '\n'  
	# using advanced index for column 
	y = x[1:4,[1,2]] 
	print 'Slicing using advanced index for column:' 
	print y
	
	o/p:
	Our array is:
	[[ 0  1  2] 
	 [ 3  4  5] 
	 [ 6  7  8]
	 [ 9 10 11]]
	 
	After slicing, our array becomes:
	[[ 4  5]
	 [ 7  8]
	 [10 11]]

	Slicing using advanced index for column:
	[[ 4  5]
	 [ 7  8]
	 [10 11]]

	 
Boolean array indexing:
This indexing is used when the resultant object is meant to be the result of Boolean operations, such as comparison operators.

example 1,
	import numpy as np 
	a = np.array([1,2,10,11,4]) 
	print a[a > 5]

	O/p: [10,11]
	
example 2,
	import numpy as np 
	a = np.array([np.nan, 1,2,np.nan,3,4,5]) 
	print a[~np.isnan(a)]

	O/p: [ 1.   2.   3.   4.   5.] 
	
example 3,
	import numpy as np 
	a = np.array([1, 2+6j, 5, 3.5+5j]) 
	print a[np.iscomplex(a)]

O/p: [2.0+6.j  3.5+5.j] 
----------------------------------------------------------------------------------------------------------
Numpy operation in csv or text file.

numpy.genfromtxt function can be used to directly read csv or other files into arrays.
example,
wines = np.genfromtxt("winequality-red.csv", delimiter=";", skip_header=1)

o/p: array([[  7.4  ,   0.7  ,   0.   , ...,   0.56 ,   9.4  ,   5.   ],
       [  7.8  ,   0.88 ,   0.   , ...,   0.68 ,   9.8  ,   5.   ],
       [  7.8  ,   0.76 ,   0.04 , ...,   0.65 ,   9.8  ,   5.   ],
       ..., 
       [  6.3  ,   0.51 ,   0.13 , ...,   0.75 ,  11.   ,   6.   ],
       [  5.9  ,   0.645,   0.12 , ...,   0.71 ,  10.2  ,   5.   ],
       [  6.   ,   0.31 ,   0.47 , ...,   0.66 ,  11.   ,   6.   ]])

 

