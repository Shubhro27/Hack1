http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-2-Numpy.ipynb

----------------------------------
NumPy stands for Numerical Python is a library consisting of multidimensional array objects and functions to process them

NumPy is often used along with packages like SciPy (Scientific Python) and Mat-plotlib (plotting library) for technical computing (Matlab can also be used for same)

Using NumPy, a developer can perform the following operations -
a) Mathematical and logical operations on arrays.
b) Fourier transforms and routines for shape manipulation.
c) Operations related to linear algebra. NumPy has in-built functions for linear algebra and random number generation.

Note: Standard Python distribution doesn't come bundled with NumPy module. A lightweight alternative is to install NumPy using popular Python package installer, pip.
      pip install numpy
	  
	  
Why NumPy?
coz fortran is 100X faster than Python as, 
Python is interpreted, dynamically typed language and hence there is a small type checking overhead on iterations.
i.e. in python, the data type of a variable is interpreted runtime, in case of loops, for each loop, the data type is checked hence causes processing overhead
Numpy pushes repeated operation into statically typed compilation layer and hence save time for checking data type while looping thru each iterations. 
	  
----------------------------
ndarray: N-dimensional array is array of items of the same type.Items in the collection can be accessed using a zero-based index.
         Each element in ndarray is an object of data-type object (called dtype).
		 ndarrays are usually of fixed size and can be multidimensional. 
		 
		 In a NumPy array, the number of dimensions is called the rank, and each dimension is called an axis. 
		 So the rows are the first axis, and the columns are the second axis.
		 
		 NOTE: One of the limitations of NumPy is that all the elements in an array have to be of the same type
		 
axis explained with examples,
2 dimensional arrays:
	x = np.array([[1, 2, 3], [4,5,6],[7,8,9]], np.int32)

	O/p: 
	array([[1, 2, 3],
		   [4, 5, 6],
		   [7, 8, 9]], dtype=int32)

	x.sum(axis=0)  
	# sum the columns [1,4,7] = 12, [2,5,8] = 15 [3,6,9] = 18  
	array([12, 15, 18])

	x.sum(axis=1)    
	# sum the rows [1,2,3] = 6, [4,5,6] = 15 [7,8,9] = 24
	array([ 6, 15, 24])

3 dimensional arrays:
	x = np.array((((1,2), (3,4) ), ((5,6),(7,8))))
	O/p:
	array([[[1, 2],
		   [3, 4]],
		  [[5, 6],
		   [7, 8]]])
	x.shape 
	# dimensions of the array : (2, 2, 2)

	x.sum(axis=0)   i.e. sum of 3rd dimension
	# O/p:
	array([[ 6,  8],   #  [1,5] = 6 [2,6] = 8 [3,7] = 10 [4, 8] = 12
		  [10, 12]])
		  
	x.sum(axis=1)   i.e. columns
	# O/p:
	array([[ 4,  6],   # [1,3] = 4 [2,4] = 6 [5, 7] = 12 [6, 8] = 14
		   [12, 14]])
		   
	x.sum(axis=2)   i.e. rows 
	# O/p: 
	[1, 2] = 3 [3, 4] = 7 [5, 6] = 11 [7, 8] = 15

	array([[ 3,  7],
		   [11, 15]])

	x.ndim # number of dimensions of the array
	3

-	
The basic ndarray is created using,
1) numpy.array.
	example-1,
	import numpy as np 
	a = np.array([1,2,3])     //NOTE, this format ([]) is important. () will not work. 
	print a  //o/p: [1, 2, 3]
	
	example-2,
	import numpy as np 
	a = np.array([[1, 2], [3, 4]]) 
	print a  
	
	//o/p: [[1, 2] 
			[3, 4]]
			
2) numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)
	where,
	a) object: any sequence or nested sequence
	b) dtype: desired data type of the array. THIS IS OPTIONAL
	c) copy: for copying the object. By default, it is "True". ALSO OPTIONAL
	d) order: has 3 values, A -> any (DEFAULT), C -> row major, F -> column major
	e) subok
	f) ndmin: specifies minimum dimensions of the resultant array.
	
	example-1,
		import numpy as np 
		a = np.array([1, 2, 3,4,5], ndmin = 2) 
		print a
		
		o/p:
		[[1, 2, 3, 4, 5]]
	
	example-2,
		import numpy as np 
		a = np.array([1, 2, 3], dtype = complex) 
		print a
		
		o/p:
		[ 1.+0.j,  2.+0.j,  3.+0.j]


the number of dimensions and items in an array is defined by its shape, which is a tuple of N positive integers that specify the sizes of each dimension. 
example,
//A 2-dimensional array of size 2 x 3, composed of 4-byte integer elements
x = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
type(x)  //o/p: <type 'numpy.ndarray'>

x.shape  //o/p: (2, 3)

x.dtype  //o/p: dtype('int32')

-----------------------------------------
Data Types:

NumPy stores values using its own data types, which are distinct from Python types like float and str. 
This is because the core of NumPy is written in a programming language called C, which stores data differently than the Python data types. 
NumPy data types map between Python and C, allowing us to use NumPy arrays without any conversion hitches.

bool_    : for boolean
int8     : Byte (-128 to 127)
int16    : Integer (-32768 to 32767)
int32    : Integer (-2147483648 to 2147483647)
int64    : Integer (-9223372036854775808 to 9223372036854775807)
uint8    : Unsigned integer (0 to 255)
uint16   : Unsigned integer (0 to 65535)
uint32   : Unsigned integer (0 to 4294967295)
uint64   : Unsigned integer (0 to 18446744073709551615)
float16  : Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
float32  : Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
float64  : Double precision float
complex64: two 32-bit floats 
complex128: two 64-bit floats
int_      : default integer type. used for int32 or int64
float_    : Shorthand for float64

dtype: i.e data type object
dtype are arrays which can have combinations of fundamental data types. 
This is different from numpy arrays as numpy arrays only store fundamental numeric data types (int and float).

dtype allows us to create structured arrays (i.e. "record arrays")
example, 
Country			Population Density		Area		Population
Netherlands 	393 					41526 		16,928,800 
Belgium 		337 					30510 		11,007,020 
United Kingdom 	256 					243610 		62,262,000 

example of dtype,
	import numpy as np
	i16 = np.dtype(np.int16)			//We define an int16 
	print(i16)
	lst = [ [3.4, 8.7, 9.9], 
			[1.1, -7.8, -0.7],
			[4.1, 12.3, 4.8] ]
	A = np.array(lst, dtype=i16)       //The elements of the list 'lst' are turned into i16 types to create the two-dimensional array A.
	print(A)
	
	o/p:
	int16
	[[ 3  8  9]
	 [ 1 -7  0]
	 [ 4 12  4]]

A dtype object is constructed using the following syntax -
numpy.dtype(object, align, copy)
where,
	Object - To be converted to data type object
	Align  - If true, adds padding to the field to make it similar to C-struct
	Copy   - Makes a new copy of dtype object. If false, the result is reference to builtin data type object

built in data type short hand,
'b' - boolean
'i' - (signed) integer
'u' - unsigned integer
'f' - floating-point
'c' - complex-floating point
'm' - timedelta
'M' - datetime
'O' - (Python) objects
'S', 'a' - (byte-)string
'U' - Unicode
'V' - raw data (void)

creating structured arrays via datatype,
reconsider the example using,
Country			Population Density		Area		Population
Netherlands 	393 					41526 		16,928,800 
Belgium 		337 					30510 		11,007,020 
United Kingdom 	256 					243610 		62,262,000 

import numpy as np
dt = np.dtype([('density', np.int32)])
x = np.array([(393,), (337,), (256,)],dtype=dt)
print(x) 
print("\nThe internal representation:")
print(repr(x))
print(x['density'])    //access the content of density column.

o/p,
[(393,) (337,) (256,)]
The internal representation:
array([(393,), (337,), (256,)],
      dtype=[('density', '<i4')])
[393 337 256]

same example with data type short hand,
dt = np.dtype([('density', 'i4')])       //here, The 'i' means integer and the 4 means 4 bytes
x = np.array([(393,), (337,), (256,)],
             dtype=dt)
print(x)                                 //o/p: [(393,) (337,) (256,)]


What is less-than sign in front of i4 in the result?
'<' - means that the encoding will be little-endian.
'>' - means that the encoding will be big-endian.
no Prefix - native byte ordering.

example,
# little-endian ordering
dt = np.dtype('<d')
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 = 8
# big-endian ordering
dt = np.dtype('>d')  
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 > 8
# native byte ordering
dt = np.dtype('d') 
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 = 8

example, (to define the entire dataset)
dt = np.dtype([('country', 'S20'), ('density', 'i4'), ('area', 'i4'), ('population', 'i4')])
population_table = np.array([
    ('Netherlands', 393, 41526, 16928800),
    ('Belgium', 337, 30510, 11007020),
    ('United Kingdom', 256, 243610, 62262000)],dtype = dt)
print ( population_table )
print ("\n")
print ( population_table[:1])
print(population_table['density'])
print(population_table['country'])
print(population_table['area'][:2])

o/p:
[(b'Netherlands', 393,  41526, 16928800)
 (b'Belgium', 337,  30510, 11007020)
 (b'United Kingdom', 256, 243610, 62262000)]
 
[(b'Netherlands', 393,  41526, 16928800)]

[393 337 256]
[b'Netherlands' b'Belgium' b'United Kingdom']
[41526,30510]


Datatype explicit conversion:
numpy.ndarray.astype is used for explicit conversion.
example, 
wines.astype(int)

dt = np.dtype([('density', np.float32)])
x = np.array([(393,), (337,), (256,)],dtype=dt)
print(x['density'])    //access the content of density column.
int_x = x.astype(int32)
print (int_x['density'])

o/p,
[393.0 337.0 256.0]
[393 337 256]

-------------------------------------------------------------
Array Attributes:
1) ndarray.shape: returns a tuple consisting of array dimensions
	example,
		import numpy as np 
		a = np.array([[1,2,3],[4,5,6]]) 
		print (a.shape)                     //re-sizes the ndarray 
		b = np.array([[1,2,3],[4,5,6]])
		b.shape = (3,2)
		print (b)
		c = a.reshape(3,2)               //re-size function to resize an array. 
		print (c)
		
	o/p:
	(2, 3)
	[[1, 2] 
	 [3, 4] 
	 [5, 6]]
	[[1, 2] 
	 [3, 4] 
	 [5, 6]]
	 
2) arange: returns an array with predefined range.
	example,
		import numpy as np 
		a = np.arange(24)     //Note: the range will start with 0 
		print (a)
		b = a.reshape(2,4,3)  //3 dimensional array
		print (b)
		
		
	o/p: 
	[0 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16 17 18 19 20 21 22 23]
	[[[ 0,  1,  2] 
	  [ 3,  4,  5] 
	  [ 6,  7,  8] 
	  [ 9, 10, 11]]  
	  [[12, 13, 14] 
	   [15, 16, 17]
	   [18, 19, 20] 
    [21, 22, 23]]] 
	
3) ndarray.ndim: returns the number of array dimensions.
	example,
		import numpy as np 
		a = np.arange(24)     //Note: the range will start with 0 
		print (a.ndim)
		b = a.reshape(2,4,3)  //3 dimensional array
		print (b.ndim)
		
	o/p:
	1
	3

4) numpy.itemsize: returns the length of each element of array in bytes.
	example,
		# dtype of array is int8 (1 byte) , float32 (4 bytes)
		import numpy as np 
		x = np.array([1,2,3,4,5], dtype = np.int8) 
		print x.itemsize
		y = np.array([1,2,3,4,5], dtype = np.float32)
		print y.itemsize
		
	o/p: 
	1
	4
	
---------------------------------------------------------------------
Array Creation Routines:
A new ndarray object can be created and initialized via,
1) numpy.empty: creates an uninitialized array of specified shape and dtype
	Syntax: numpy.empty(shape, dtype = float, order = 'C')
			where Order -> 'C' for C-style row-major array, 'F' for FORTRAN style column-major array.
			
	example,
	import numpy as np 
	x = np.random.rand(3,3)   //do not use ([3,3]), it will error.
	print x
	y = np.random.randn(3,3)  //allows negative random numbers.
	print y

	o/p, will be random values as,
	[[ 0.01981698  0.09110606  0.23935331]
	 [ 0.89677127  0.35218767  0.30102867]
	 [ 0.73461755  0.82675736  0.3544581 ]]
	#
	[[ 0.92525075 -0.90478616  1.84369153]
	 [ 1.52550724 -1.44553558  0.37716061]
	 [-0.07055723  0.60415971  0.472149  ]]
	 
	these values will change each time it is run.
	
	example-2, random with seed value, seeding keeps the random numbers intact in subsequent runs,
		import numpy as np
		np.random.seed(0)  #seed can take any value 0,1,2.
		print(np.random.randn(3,3))
	
	o/p:
	[[ 1.76405235  0.40015721  0.97873798]
	 [ 2.2408932   1.86755799 -0.97727788]
	 [ 0.95008842 -0.15135721 -0.10321885]]
	 
	NOTE: For numpy.random.seed(), the main difficulty is that it is not thread-safe - 
	that is, it's not safe to use if you have many different threads of execution, 
	because it's not guaranteed to work if two different threads are executing the function at the same time. 
	If you're not using threads, and if you can reasonably expect that you won't need to rewrite your program 
	this way in the future, numpy.random.seed() should be fine for testing purposes.
	If there's any reason to suspect that you may need threads in the future, 
	it's much safer in the long run to do as suggested, and to make a local instance of the numpy.random.Random class. 
	As far as I can tell, random.random.seed() is thread-safe 
	
	By using np.Random.Seed(i) where 'i' can be any integer, 
	you make sure that while generating random numbers you generate the same set of numbers 
	in a different sequence each time until the next seed is provided.
	
	 
2) numpy.zeros: creates a new array of specified size, filled with zeroes.

	example1,
	# array of five zeros. Default dtype is float 
	import numpy as np 
	x = np.zeros(5) 
	print x
	
	o/p, [ 0.  0.  0.  0.  0.]
	
	example2,
	# custom type 
	import numpy as np 
	x = np.zeros((2,2), dtype = [('x', 'i4'), ('y', 'i4')])  
	print x
	
	o/p:
	[[(0,0)(0,0)]
	[(0,0)(0,0)]] 
	
	even,
	x = np.empty([3,2], dtype = int) will create 2*2 matrix with all Zeroes
	
3) numpy.ones: similar to numpy.zeroes except arrays are filled with ones.
------------------------------------------------------------
Array From Existing Data (ex, array, tuples etc)

1) numpy.asarray: 
	example 1,
		import numpy as np 
		x = [1,2,3] 
		a = np.asarray(x) 
		print a
		
	o/p: [1  2  3]
	
	example 2,
		import numpy as np 
		x = [1,2,3]
		a = np.asarray(x, dtype = float) 
		print a
		
	o/p: [ 1.  2.  3.] 
	
	example 3,
		import numpy as np 
		x = (1,2,3) 
		a = np.asarray(x) 
		print a
		
	o/p: [1  2  3]
	
2) numpy.frombuffer: interprets a buffer as one-dimensional array.
	syntax: numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)
			where,
			count : The number of items to read, default -1 means all data
			offset: The starting position to read from. Default is 0
			
	example,
		import numpy as np 
		s = 'Hello World' 
		a = np.frombuffer(s, dtype = 'S1') 
		print a
	
	o/p: ['H'  'e'  'l'  'l'  'o'  ' '  'W'  'o'  'r'  'l'  'd']
	
	
3) numpy.fromiter: This function builds a new ndarray object from any iterable object.
	example,
		import numpy as np 
		list = range(5) 
		it = iter(list)  
		# use iterator to create ndarray 
		x = np.fromiter(it, dtype = float) 
		print x

	o/p: [0.   1.   2.   3.   4.]
	
4) numpy.arange: create an array from numerical ranges.
	syntax, numpy.arange(start, stop, step, dtype)
			where,
			start -> The start of an interval. If omitted, defaults to 0
			stop  -> The end of an interval (not including this number)
			step  -> Spacing between values, default is 1
			
	example,
		import numpy as np
		x = np.arange(5)      //arange will skip the "stop" value, i.e. in this case, it is 5, so x will be [1 2 3 4]
		print x
		y = np.arange(5, dtype = float)
		print y
		z = np.arange(10,20,2)   //will skip "20" i.e. stop value.
		print z

	o/p:
	[0  1  2  3  4]
	[0.  1.  2.  3.  4.] 
	[10  12  14  16  18]
	
 5) reverse an array: 1d arrays can be reversed in 2 ways via numpy,
	a) arr[::-1] will reverse the array arr.
	b) np.flipud(<arr>) will also reverse the array passed.
	
	example,
		v1 = np.arange(10,50)
		print v1
		v2 = v1[::-1]
		print v2
		v3 = np.flipud(v1)
		print v3
		
	o/p:
	[10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49]
	[49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10]
	[49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10]

	for 2-d arrays, we can also use np.fliplr() flips the array left to right. But this does not work on 1-D arrays.
	It will error with,
	ValueError: Input must be >= 2-d.	
	
---------------------------------------------------------------------------
Indexing & Slicing:

used to access and modify ndarrays. There are three types of indexing methods are available - 
field access 
basic slicing
advanced indexing.

example 1,
	import numpy as np 
	a = np.arange(10)   //[0 1 2 3 4 5 6 7 8 9] 
	s = slice(2,7,2)    //i.e. start, stop, and step 
	print a[s]
	b = a[2:7:2] 
	print b
	c = a[5] 
	print c
	print a[2:]
	print a[2:5]
	z = np.array([[1,2,3],[3,4,5],[4,5,6]]) 
	print z
	print 'Now we will slice the array from the index a[1:]' 
	print a[1:]
	
	o/p: 
	[2  4  6]
	[2  4  6]
	5
	[2  3  4  5  6  7  8  9]
	[2  3  4]
	[[1 2 3]
	 [3 4 5]
	 [4 5 6]]
	Now we will slice the array from the index a[1:]
	[[3 4 5]
	 [4 5 6]]
	
example 2,
	# array to begin with 
	import numpy as np 
	a = np.array([[1,2,3],[3,4,5],[4,5,6]]) 

	print 'Our array is:' 
	print a 
	print '\n'  

	# this returns array of items in the second column 
	print 'The items in the second column are:'  
	print a[...,1] 
	print '\n'  

	# Now we will slice all items from the second row 
	print 'The items in the second row are:' 
	print a[1,...] 
	print '\n'  

	# Now we will slice all items from column 1 onwards 
	print 'The items column 1 onwards are:' 
	print a[...,1:]
	
	o/p:
	Our array is:
	[[1 2 3]
	 [3 4 5]
	 [4 5 6]] 
	 
	The items in the second column are: 
	[2 4 5] 

	The items in the second row are:
	[3 4 5]

	The items column 1 onwards are:
	[[2 3]
	 [4 5]
	 [5 6]] 

	 
Integer Indexing,
you can select any arbitrary item in an array based on its Ndimensional index.
example 1,
	import numpy as np 
	x = np.array([[1, 2], [3, 4], [5, 6]]) 
	y = x[[0,1,2], [0,1,0]] 		//includes elements at (0,0), (1,1) and (2,0) from x	
	print y

	o/p: [1  4  5]
	
example 2, will give the corner values [COULD NOT UNDERSTAND THIS EXAMPLE]
	import numpy as np 
	x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
	print 'Our array is:' 
	print x 
	print '\n' 
	rows = np.array([[0,0],[3,3]])    //[[ 9 10 11]  [ 9 10 11]]]
	cols = np.array([[0,2],[0,2]])    //[[[0 1 2]  [6 7 8]] [[0 1 2]  [6 7 8]]]
	y = x[rows,cols] 
	print 'The corner elements of this array are:' 
	print y

	o/p,
	Our array is:                                                                 
	[[ 0  1  2]                                                                   
	 [ 3  4  5]                                                                   
	 [ 6  7  8]                                                                   
	 [ 9 10 11]]
	 
	The corner elements of this array are:                                        
	[[ 0  2]                                                                      
	 [ 9 11]] 
	 
	 
Slicing an array:
example,
	import numpy as np 
	x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
	print 'Our array is:' 
	print x 
	print '\n'  
	# slicing 
	z = x[1:4,1:3]     //AS IT WILL IGNORE THE LAST ELEMENT, i.e. it will consider 1:3,1:2
	print 'After slicing, our array becomes:' 
	print z 
	print '\n'  
	# using advanced index for column 
	y = x[1:4,[1,2]] 
	print 'Slicing using advanced index for column:' 
	print y
	
	o/p:
	Our array is:
	[[ 0  1  2] 
	 [ 3  4  5] 
	 [ 6  7  8]
	 [ 9 10 11]]
	 
	After slicing, our array becomes:
	[[ 4  5]
	 [ 7  8]
	 [10 11]]

	Slicing using advanced index for column:
	[[ 4  5]
	 [ 7  8]
	 [10 11]]

	 
Boolean array indexing:
This indexing is used when the resultant object is meant to be the result of Boolean operations, such as comparison operators.

example 1,
	import numpy as np 
	a = np.array([1,2,10,11,4]) 
	print a[a > 5]

	O/p: [10,11]
	
example 2,
	import numpy as np 
	a = np.array([np.nan, 1,2,np.nan,3,4,5]) 
	print a[~np.isnan(a)]

	O/p: [ 1.   2.   3.   4.   5.] 
	
example 3,
	import numpy as np 
	a = np.array([1, 2+6j, 5, 3.5+5j]) 
	print a[np.iscomplex(a)]

O/p: [2.0+6.j  3.5+5.j] 
------------------------------------------------------------------------------------------------
Broadcasting,

Arithmetic operations on arrays are usually done on corresponding elements i.e. the 2 arrays should be of same size.

example,
	import numpy as np 
	a = np.array([1,2,3,4]) 
	b = np.array([10,20,30,40]) 
	c = a * b 
	print c

	o/p:
	[10   40   90   160]
	
Broadcasting in Numpy allows operations on arrays of non-similar shapes.
i.e. The smaller array is broadcast to the size of the larger array so that they have compatible shapes.

Broadcasting is possible on following cases:
1) Array with smaller dimension is prepended with 1.
2) Dimension of o/p array is same as the i/p array with bigger dimension.
3) If the dimension lengths aren't equal, and none of the dimensions have length 1, then there's an error.
4) If an input has a dimension size of 1, the first data entry in that dimension is used for 
	all calculations along that dimension.
	
example,
	import numpy as np 
	a = np.array([[0.0,0.0,0.0],[10.0,10.0,10.0],[20.0,20.0,20.0],[30.0,30.0,30.0]])     //shape (4,3)
	b = np.array([1.0,2.0,3.0])                                                          //shape (3,)
	# 
	print 'First array:' 
	print a 
	print '\n'  
	#  
	print 'Second array:' 
	print b 
	print '\n'  
	#  
	print 'First Array + Second Array' 
	print a + b
	
O/p:
First array:
[[ 0. 0. 0.]
 [ 10. 10. 10.]
 [ 20. 20. 20.]
 [ 30. 30. 30.]]

Second array:
[ 1. 2. 3.]

First Array + Second Array
[[ 1. 2. 3.]
 [ 11. 12. 13.]
 [ 21. 22. 23.]
 [ 31. 32. 33.]]

The following shapes are compatible, 
1) A: (50,3) & B: (3,) although B is then out of elements
	BUT the length of the trailing dimension of array A is 3, and the length of the trailing dimension of array B is 3
	They're equal, so that dimension is okay.

2) A: (1,2) & B: (50,2) The last dimension matches, and A is of length 1 in the first dimension.

The following shapes are not compatible,
1) A: (50,50) & B: (49,49) The lengths of the dimensions aren't equal, and neither array has either dimension length equal to 1.

	
----------------------------------------------------------------
Iterating Over Array:

a) numpy.nditer is an efficient multidimensional iterator object using which it is possible to iterate over an array.

example 1,
	import numpy as np
	a = np.arange(0,60,5)
	print 'Original array is:'
	print a
	a = a.reshape(3,4)
	print a
	for x in np.nditer(a):
	   print x,

	o/p:
	[ 0  5 10 15 20 25 30 35 40 45 50 55]

	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]
	 
	0 5 10 15 20 25 30 35 40 45 50 55
	
example 2, (transposing an array)
	import numpy as np 
	a = np.arange(0,60,5) 
	a = a.reshape(3,4) 
	   
	print 'Original array is:'
	print a 
	print '\n'  
	   
	print 'Transpose of the original array is:' 
	b = a.T 
	print b 
	print '\n'  
	   
	print 'Modified array is:' 
	for x in np.nditer(b): 
	   print x,

o/p:
Original array is:
[[ 0 5 10 15]
 [20 25 30 35]
 [40 45 50 55]]

Transpose of the original array is:
[[ 0 20 40]
 [ 5 25 45]
 [10 30 50]
 [15 35 55]]

Modified array is:
0 5 10 15 20 25 30 35 40 45 50 55

b) Iteration Order
	a) if elements are stored using C-style order, the iterator iterates row wise.
	b) if elements are stored using F-style order, the iterator iterates column wise.
	
example,
	import numpy as np
	a = np.arange(0,60,5)
	a = a.reshape(3,4)
	print 'Original array is:'
	print a
	print '\n'

	print 'Transpose of the original array is:'
	b = a.T
	print b
	print '\n'

	print 'Sorted in C-style order:'
	c = b.copy(order='C')
	print c
	for x in np.nditer(c):
	   print x,

	print '\n'

	print 'Sorted in F-style order:'
	c = b.copy(order='F')
	print c
	for x in np.nditer(c):
	   print x,
	   
o/p:
	Original array is:
	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]

	Transpose of the original array is:
	[[ 0 20 40]
	 [ 5 25 45]
	 [10 30 50]
	 [15 35 55]]

	Sorted in C-style order:
	[[ 0 20 40]
	 [ 5 25 45]
	 [10 30 50]
	 [15 35 55]]
	0 20 40 5 25 45 10 30 50 15 35 55

	Sorted in F-style order:
	[[ 0 20 40]
	 [ 5 25 45]
	 [10 30 50]
	 [15 35 55]]
	0 5 10 15 20 25 30 35 40 45 50 55
	
----------------------------------------------------------------------------------------------------------
Modifying array values:

nditer can also be used to modify array values with optional parameter called "op_flags".
op_flags values are,
1) Its default value is read-only, 
2) To enable modifying array elements with,
	a) read-write 
	b) write-only mode.

for instance, "np.nditer(a, op_flags=['readwrite'])"

example,
	import numpy as np
	a = np.arange(0,60,5)
	a = a.reshape(3,4)
	print 'Original array is:'
	print a
	print '\n'

	for x in np.nditer(a, op_flags=['readwrite']):
	   x[...]=2*x
	print 'Modified array is:'
	print a
	
o/p:
	Original array is:
	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]

	Modified array is:
	[[ 0 10 20 30]
	 [ 40 50 60 70]
	 [ 80 90 100 110]]
	 

Broadcasting Iteration:
i.e. combined nditer object is able to iterate thru multiple arrays concurrently as,

example,
	import numpy as np 
	a = np.arange(0,60,5) 
	a = a.reshape(3,4) 
	#
	print 'First array is:' 
	print a 
	print '\n'  
	#
	print 'Second array is:' 
	b = np.array([1, 2, 3, 4], dtype = int) 
	print b  
	print '\n' 
	#
	print 'Modified array is:' 
	for x,y in np.nditer([a,b]): 
	   print "%d:%d" % (x,y),
	   
o/p:
	First array is:
	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]

	Second array is:
	[1 2 3 4]

	Modified array is:
	0:1 5:2 10:3 15:4 20:1 25:2 30:3 35:4 40:1 45:2 50:3 55:4
	 
----------------------------------------------------------------------------------------------------------
Array Manipulation:

1) changing shape (dimensions) of the array. 
	a) reshape,
		example,
			import numpy as np
			a = np.arange(8)
			print 'The original array:'
			print a
			print '\n'
			#
			b = a.reshape(4,2)
			print 'The modified array:'
			print b
	
		o/p:
		[0 1 2 3 4 5 6 7]
		The modified array:
		[[0 1]
		 [2 3]
		 [4 5]
		 [6 7]]
		 
	b) flatten, returns a copy of an array collapsed into one dimension.
		example,
			import numpy as np 
			a = np.arange(8).reshape(2,4) 
			#
			print 'The original array is:' 
			print a 
			print '\n'  
			# default is column-major 
			print 'The flattened array is:' 
			print a.flatten() 
			print '\n'  
			print 'The flattened array in F-style ordering:' 
			print a.flatten(order = 'F')
			
		o/p:
			The original array is:
			[[0 1 2 3]
			 [4 5 6 7]]

			The flattened array is:
			[0 1 2 3 4 5 6 7]

			The flattened array in F-style ordering:
			[0 4 1 5 2 6 3 7]
			
	c) ravel: returns a flattened one-dimensional array. A copy is made only if needed.
		example,
			import numpy as np 
			a = np.arange(8).reshape(2,4) 
			#
			print 'The original array is:' 
			print a 
			print '\n'  
			#
			print 'After applying ravel function:' 
			print a.ravel()  
			print '\n' 
			#
			print 'Applying ravel function in F-style ordering:' 
			print a.ravel(order = 'F')
			
		o/p:
		The original array is:
		[[0 1 2 3]
		 [4 5 6 7]]

		After applying ravel function:
		[0 1 2 3 4 5 6 7]

		Applying ravel function in F-style ordering:
		[0 4 1 5 2 6 3 7]
		
2) Transpose Operations: 
	a) transpose: permutes the dimension of the given array.
	   example,
			import numpy as np 
			a = np.arange(12).reshape(3,4) 
			print 'The original array is:' 
			print a  
			print '\n' 
			print 'The transposed array is:' 
			print np.transpose(a)
		
		o/p:
		The original array is:
		[[ 0 1 2 3]	
		 [ 4 5 6 7]
		 [ 8 9 10 11]]

		The transposed array is:
		[[ 0 4 8]
		 [ 1 5 9]
		 [ 2 6 10]
		 [ 3 7 11]]
		 
	b) ndarray.T: same functionality as transpose,
		example,
			a = np.arange(12).reshape(3,4)
			print a.T
		
		o/p: same as transpose.
		
3) Joining Arrays:
	a) numpy.concatenate: NOTE:  all the input arrays must have same number of dimensions
		example,
			import numpy as np 
			a = np.array([[1,2],[3,4]]) 
			#
			print 'First array:' 
			print a 
			print '\n'  
			b = np.array([[5,6],[7,8]]) 
			#
			print 'Second array:' 
			print b 
			print '\n'  
			# both the arrays are of same dimensions 
			print 'Joining the two arrays along axis 0:' 
			print np.concatenate((a,b)) 
			print '\n'  
			print 'Joining the two arrays along axis 1:' 
			print np.concatenate((a,b),axis = 1)
			
		o/p:
			First array:
			[[1 2]
			 [3 4]]

			Second array:
			[[5 6]
			 [7 8]]

			Joining the two arrays along axis 0:
			[[1 2]
			 [3 4]
			 [5 6]
			 [7 8]]

			Joining the two arrays along axis 1:
			[[1 2 5 6]
			 [3 4 7 8]]
			 
	b) numpy.stack: concatenates and syntax is numpy.stack(arrays, axis), NOTE: all input arrays must have the same shape
		example,
			import numpy as np 
			a = np.array([[1,2],[3,4]]) 
			#
			print 'First Array:' 
			print a 
			print '\n'
			b = np.array([[5,6],[7,8]]) 
			#
			print 'Second Array:' 
			print b 
			print '\n'  
			#
			print 'Stack the two arrays along axis 0:' 
			print np.stack((a,b),0) 
			print '\n'  
			#
			print 'Stack the two arrays along axis 1:' 
			print np.stack((a,b),1)
			
		o/p:
		First array:
		[[1 2]
		 [3 4]]

		Second array:
		[[5 6]
		 [7 8]]

		Stack the two arrays along axis 0:
		[[[1 2]
		 [3 4]]
		 [[5 6]
		 [7 8]]]

		Stack the two arrays along axis 1:
		[[[1 2]
		 [5 6]]
		 [[3 4]
		 [7 8]]]
		 
	c) numpy.hstack and numpy.vstack: hstack to make a single array horizontally. vstack to make a single array vertically.
		example,
		a = np.array([[1,2],[3,4]]) 
		b = np.array([[5,6],[7,8]]) 
		c = np.hstack((a,b)) 
		d = np.vstack((a,b)) 
		
		o/p:
		Horizontal stacking:
		[[1 2 5 6]
		 [3 4 7 8]]
		 
		Vertical stacking:
		[[1 2]
		 [3 4]
		 [5 6]
		 [7 8]]
		 
4) Array Splitting.
	a) numpy.split: divides the array into subarrays along a specified axis
		syntax is : numpy.split(array, indices_or_sections, axis)
					where,
					 indices_or_sections: indicating the number of equal sized subarrays to be created from the input array,
										  If this parameter is a 1-D array, the entries indicate the points at which a new subarray is to be created.
										  
					 axis: default is ZERO
					 
		example,
		a = np.arange(9)   //[0 1 2 3 4 5 6 7 8]
		b = np.split(a,3)  //b[0] will give 1st splitted array, b[1] will be 2nd splitted array.
		b = np.split(a,[4,7])  //i.e. 1-D array as sections
		
		o/p:
		[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]
		[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]
		
	b) numpy.hsplit and numpy.vsplit: hsplit - axis is 1 indicating a horizontal split; vsplit - axis is 1 indicating a vertical split
		example,
		a = np.arange(16).reshape(4,4) 
		b = np.hsplit(a,2)
		c = np.vsplit(a,2)

		o/p:
		First array:
		[[ 0 1 2 3]
		 [ 4 5 6 7]
		 [ 8 9 10 11]
		 [12 13 14 15]]
		 
		Horizontal splitting:                                                         
		[array([[ 0,  1],                                                             
			   [ 4,  5],                                                              
			   [ 8,  9],                                                              
			   [12, 13]]), array([[ 2,  3],                                           
			   [ 6,  7],                                                              
			   [10, 11],                                                              
			   [14, 15]])] 
			   
		Vertical splitting:                                                           
		[array([[0, 1, 2, 3],                                                         
			   [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],                               
			   [12, 13, 14, 15]])] 
			   
5) Adding / Removing Elements
	a) resize: numpy.resize(arr, shape) 
		example,
			a = np.array([[1,2,3],[4,5,6]]) 
			b = np.resize(a, (3,2)) 
			c = np.resize(a, (3,3))
		
		o/p:
		First array:
		[[1 2 3]
		 [4 5 6]]
		 
		Second array:
		[[1 2]
		 [3 4]
		 [5 6]]
		 
		third array:
		[[1 2 3]
		 [4 5 6]
		 [1 2 3]]
		 
	b) append: numpy.append(arr, values, axis), axis: by default, both parameters are flattened
		example,
			a = np.array([[1,2,3],[4,5,6]]) 
			print np.append(a, [7,8,9]) 
			print np.append(a, [[7,8,9]],axis = 0) 
			print np.append(a, [[5,5,5],[7,8,9]],axis = 1)
		
		o/p:
		First array:
		[[1 2 3]
		 [4 5 6]]

		Append elements to array:
		[1 2 3 4 5 6 7 8 9]

		Append elements along axis 0:
		[[1 2 3]
		 [4 5 6]
		 [7 8 9]]

		Append elements along axis 1:
		[[1 2 3 5 5 5]
		 [4 5 6 7 8 9]]
		 
	c) numpy.insert: inserts values in the input array along the given axis and before the given index. Insertion creates a new array.
		numpy.insert(arr, obj, values, axis) where obj: The index before which insertion is to be made
		
		example,
		a = np.array([[1,2],[3,4],[5,6]])
		print np.insert(a,3,[11,12])   //if no axis is provided, input array is flattened
		print np.insert(a,1,[11],axis = 0) 
		print np.insert(a,1,11,axis = 1)
		
		o/p:
		First array:
		[[1 2]
		 [3 4]
		 [5 6]]

		Axis parameter not passed. The input array is flattened before insertion.
		[ 1 2 3 11 12 4 5 6]

		Axis parameter passed. The values array is broadcast to match input array.
		Broadcast along axis 0:
		[[ 1 2]
		 [11 11]
		 [ 3 4]
		 [ 5 6]]

		Broadcast along axis 1:
		[[ 1 11 2]
		 [ 3 11 4]
		 [ 5 11 6]]
		 
	d) numpy.delete: returns a new array with the specified subarray deleted from the input array. If axis is not provided, the array is flattened.
		Numpy.delete(arr, obj, axis) where, obj: an integer or array of integers, indicating the subarray to be deleted from the input array
		example,
			import numpy as np 
			a = np.arange(12).reshape(3,4) 
			#
			print np.delete(a,5)  
			#
			print np.delete(a,1,axis = 1)  //'Column 2 deleted'
			#
			a = np.array([1,2,3,4,5,6,7,8,9,10]) 
			print np.delete(a, np.s_[::2]) //A slice containing alternate values from array deleted
			
		o/p:
			First array:
			[[ 0 1 2 3]
			 [ 4 5 6 7]
			 [ 8 9 10 11]]

			Array flattened before delete operation as axis not used:
			[ 0 1 2 3 4 6 7 8 9 10 11]

			Column 2 deleted:
			[[ 0 2 3]
			 [ 4 6 7]
			 [ 8 10 11]]

			A slice containing alternate values from array deleted:
			[ 2 4 6 8 10]
		
	e) numpy.unique: returns an array of unique elements in the input array.
					 it can return a tuple of array of unique vales and an array of associated indices.
		example,
			import numpy as np 
			a = np.array([5,2,6,2,7,5,6,8,2,9]) 
			u = np.unique(a) 

			o/p:
			First array:
			[5 2 6 2 7 5 6 8 2 9]
			Unique values of first array:
			[2 5 6 7 8 9]
			
----------------------------------------------------------------------------------------------------------
Mathematical Operations:
rounding off array elements: 
	a) numpy.around() rounds to the desired precision
		example,
		a = np.array([1.0,5.55, 123, 0.567, 25.532]) 
		print np.around(a) 
		print np.around(a, decimals = 1) 
		
		o/p:
		[   1.       5.55   123.       0.567   25.532] 
		[   1.    6.   123.    1.   26. ]  
		[   1.    5.6  123.    0.6  25.5] 
	
	b) numpy.floor() : floor of the  x is the largest integer i, such that i <= x
		example,
		a = np.array([-1.7, 1.5, -0.2, 0.6, 10]) 
		print np.floor(a)
		
		o/p:
		[ -1.7   1.5  -0.2   0.6  10. ]
		[ -2.    1.   -1.    0.   10. ]
		
	c) numpy.ceil() : the ceil of the scalar x is the smallest integer i, such that i >= x.
		example,
		a = np.array([-1.7, 1.5, -0.2, 0.6, 10]) 
		print np.ceil(a)
		
		o/p:
		[ -1.7   1.5  -0.2   0.6  10. ]
		[ -1.    2.   -0.    1.   10.]
		

Arithmetic Operations:
	a) add(), subtract(), multiply(), and divide():
		example,
			a = np.arange(9, dtype = np.float_).reshape(3,3)
			b = np.array([10,10,10])
			print np.add(a,b)
			print np.subtract(a,b) 
			print np.multiply(a,b) 
			print np.divide(a,b)
			print np.divide(a,b)
			
		o/p:
			First array:
			[[ 0. 1. 2.]
			 [ 3. 4. 5.]
			 [ 6. 7. 8.]]

			Second array:
			[10 10 10]

			Add the two arrays:
			[[ 10. 11. 12.]
			 [ 13. 14. 15.]
			 [ 16. 17. 18.]]

			Subtract the two arrays:
			[[-10. -9. -8.]
			 [ -7. -6. -5.]
			 [ -4. -3. -2.]]

			Multiply the two arrays:
			[[ 0. 10. 20.]
			 [ 30. 40. 50.]
			 [ 60. 70. 80.]]

			Divide the two arrays:
			[[ 0. 0.1 0.2]
			 [ 0.3 0.4 0.5]
			 [ 0.6 0.7 0.8]]
			 
	b) numpy.reciprocal(): 
		example,
		a = np.array([0.25, 1.33, 1, 0, 100])
		print np.reciprocal(a)
		
		o/p:
		[   0.25    1.33       1.      0.    100.  ] 
		[   4.      0.7518797  1.      inf   0.01  ]  
		
	c) numpy.power():
		example,
			a = np.array([10,100,1000]) 
			print np.power(a,2) 
			b = np.array([1,2,3])
			print np.power(a,b)    //does each element of a to the power (each element of b).
		
		o/p:
		Our array is:                                                                 
		[10  100 1000]                                                              
																																									
		Applying power function:                                                      
		[100   10000 1000000]                                                     
																																									
		Second array:                                                                 
		[1 2 3]                                                                       
																																							   
		Applying power function again:                                                
		[10 10000 1000000000]
		
	d) numpy.mod() and numpy.remainder(): produces the same result i.e. remainder of division.
		example,
			a = np.array([10,20,30]) 
			b = np.array([3,5,7]) 
			print np.mod(a,b)
			print np.remainder(a,b)
			
		o/p:
		Applying mod() function:                                                      
		[1 0 2]

		Applying remainder() function:                                                
		[1 0 2]
		
	e) numpy.real(), numpy.imag(): returns the real and imaginary part of a complex number. 
		example,
			a = np.array([-5.6j, 0.2j, 11. , 1+1j]) 
			print np.real(a)
			print np.imag(a) 
	
		o/p:
		Our array is:
		[ 0.-5.6j 0.+0.2j 11.+0.j 1.+1.j ]

		Applying real() function:
		[ 0. 0. 11. 1.]

		Applying imag() function:
		[-5.6 0.2 0. 1. ]
----------------------------------------------------------------------------------------------------------
Statistical Functions:
1) numpy.amin() and numpy.amax():
	example,
		a = np.array([[3,7,5],[8,4,3],[2,4,9]]) 
		print np.amin(a,1)
		print np.amin(a,0) 
		print np.amax(a)
		print np.amax(a, axis = 0)
	
	o/p:
	Our array is:
	[[3 7 5]
	[8 4 3]
	[2 4 9]]
	min, along row: [3 3 2]
	min, along column: [2 4 3]
	max: 9
	max, along row: [7 8 9]
	
2) mean, median and mode:
	a) numpy.mean():
		example,
			a = np.array([[1,2,3],[3,4,5],[4,5,6]]) 
			print np.mean(a) 
			print np.mean(a, axis = 0) 
			print np.mean(a, axis = 1)
		
		o/p:
		[[1 2 3]
		 [3 4 5]
		 [4 5 6]]
		 
		Applying mean() function: 3.66666666667   (i.e. all elements / 9)
		Applying mean() function along axis 0 (column): [ 2.66666667 3.66666667 4.66666667]
		Applying mean() function along axis 1 (rows): [ 2. 4. 5.]

	b) numpy.median():
		example,
		a = np.array([[30,65,70],[80,95,10],[50,90,60]]) 
		print np.median(a) 
		print np.median(a, axis = 0) 
		print np.median(a, axis = 1)
		
		o/p:
		[[30 65 70]
		 [80 95 10]
		 [50 90 60]]
		 
		Applying median() function: 65.0   (i.e. arrange all items in order and then find the middle
		Applying median() function along axis 0 (column): [ 50. 90. 60.]
		Applying median() function along axis 1 (row): [ 65. 80. 60.]

	c) numpy.average(): calculates weighted average. ex, average resulting from the multiplication of each component by a factor reflecting its importance
		example,
			a = np.array([1,2,3,4]) 
			print np.average(a) 
			b = np.arange(6).reshape(3,2) 
			wt = np.array([3,5]) 
			print np.average(a, axis = 1, weights = wt) 
		
		o/p:
		Applying average() function: 2.5
		Our array is:
		[[0 1]
		 [2 3]
		 [4 5]]

		Modified array:[ 0.625 2.625 4.625]

	d) Standard Deviation: square root of the average of squared deviations from mean. std = sqrt(mean(abs(x - x.mean())**2))
		If the array is [1, 2, 3, 4], then its mean is 2.5. Hence the squared deviations are [2.25, 0.25, 0.25, 2.25] and 
		the square root of its mean divided by 4, i.e., sqrt (5/4) is 1.1180339887498949.
		
		example,
		print np.std([1,2,3,4])
		
		o/p: 1.1180339887498949
		
	e) Variance: Variance is the average of squared deviations. i.e., mean(abs(x - x.mean())**2).
		example,
		print np.var([1,2,3,4])
		
		o/p: 1.25
----------------------------------------------------------------------------------------------------------
Sort, Search & Counting Functions:
1) numpy.sort(): returns a sorted copy of the input array.
			numpy.sort(a, axis, kind, order)
			where,
			kind -> kind of sort.Default is quicksort
			order -> If the array contains fields, the order of fields to be sorted
			
		example,
			a = np.array([[3,7],[9,1]]) 
			print np.sort(a)
			print np.sort(a, axis = 0)
			#
			dt = np.dtype([('name', 'S10'),('age', int)]) 
			a = np.array([("raju",21),("anil",25),("ravi", 17), ("amar",27)], dtype = dt) 
			print a 
			print np.sort(a, order = 'name')
		
		o/p:
		Our array is:
		[[3 7]
		 [9 1]]

		Applying sort() function:
		[[3 7]
		 [1 9]]

		Sort along axis 0:
		[[3 1]
		 [9 7]]

		Our array is:
		[('raju', 21) ('anil', 25) ('ravi', 17) ('amar', 27)]

		Order by name:
		[('amar', 27) ('anil', 25) ('raju', 21) ('ravi', 17)]
		
2) numpy.where():
	example,
		x = np.arange(9.).reshape(3, 3)
		y = np.where(x > 3) 
		print x[y]
	
	o/p:
	Our array is:
	[[ 0. 1. 2.]
	 [ 3. 4. 5.]
	 [ 6. 7. 8.]]

	Use these indices to get elements satisfying the condition
	[ 4. 5. 6. 7. 8.]

3) numpy.extract(): returns the elements satisfying any condition.
		example,
			import numpy as np 
			x = np.arange(9.).reshape(3, 3) 
			print 'Our array is:' 
			print x  
			# define a condition 
			condition = np.mod(x,2) == 0 
			#
			print 'Element-wise value of condition' 
			print condition  
			#
			print 'Extract elements using condition' 
			print np.extract(condition, x)
			
		o/p:
		Our array is:
		[[ 0. 1. 2.]
		 [ 3. 4. 5.]
		 [ 6. 7. 8.]]

		Element-wise value of condition
		[[ True False True]
		 [False True False]
		 [ True False True]]

		Extract elements using condition
		[ 0. 2. 4. 6. 8.]
		
----------------------------------------------------------------------------------------------------------
Array Comparision:

1) to compare element wise: we can do it with (arr1 == arr2)
	example 1,
		a1 = np.array([10,20,30,40,50,44])
		a2 = np.array([10,20,30,40,50,44])
		print np.array(a1 == a2)
		print ("\n")
		print np.array(a1 == a2).all()
		print ("\n")

	o/p: [ True  True  True  True  True  True ]

	example 2,
		a1 = np.array([10,20,30,40,50,44])
		a2 = np.array([10,20,30,40,50,41])
		#x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
		print np.array(a1 == a2)
		print ("\n")
		print np.array(a1 == a2).all()
		print ("\n")

	o/p: [ True  True  True  True  True False]
	
2) compare 2 arrays and summarize if 2 have same element and dimensions or not.
	example 1,
		a1 = np.array([10,20,30,40,50,44])
		a2 = np.array([10,20,30,40,50,44])
		print np.array(a1 == a2).all()

	o/p: True

	example 2,
		a1 = np.array([10,20,30,40,50,44])
		a2 = np.array([10,20,30,40,50,41])
		print np.array(a1 == a2).all()

	o/p: False
	
	NOTE: these approaches give incorrect results if,
	1) if either A or B is empty and the other one contains a single element, then .all return True. the comparison A==B returns an empty array
	2) if A and B don't have the same shape and aren't broadcastable, then this approach will raise an error.
	
3) comparing 2 arrays based on element size and array shape,
		np.array_equal(A,B)  # test if same shape, same elements values
		np.array_equiv(A,B)  # test if broadcastable shape, same elements values
		np.allclose(A,B,...) # test if same shape, elements have close enough values

----------------------------------------------------------------------------------------------------------
Numpy operation in csv or text file.

numpy.genfromtxt function can be used to directly read csv or other files into arrays.
example,
wines = np.genfromtxt("winequality-red.csv", delimiter=";", skip_header=1)

o/p: array([[  7.4  ,   0.7  ,   0.   , ...,   0.56 ,   9.4  ,   5.   ],
       [  7.8  ,   0.88 ,   0.   , ...,   0.68 ,   9.8  ,   5.   ],
       [  7.8  ,   0.76 ,   0.04 , ...,   0.65 ,   9.8  ,   5.   ],
       ..., 
       [  6.3  ,   0.51 ,   0.13 , ...,   0.75 ,  11.   ,   6.   ],
       [  5.9  ,   0.645,   0.12 , ...,   0.71 ,  10.2  ,   5.   ],
       [  6.   ,   0.31 ,   0.47 , ...,   0.66 ,  11.   ,   6.   ]])

#################################################################################
# Numpy Assignment
#################################################################################

#!/usr/bin/python
import numpy as np


1. Write a Python program to create a vector with values ranging from 10 to 49
An. 
	v1 = np.arange(10,50)
	print v1
	
	o/p:
	[10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49]
	
-------------------------------------------------------------------------------------
2. Write a Python program to reverse a vector (first element becomes last)
	An.
	v2 = v1[::-1]
	print v2
	v3 = np.flipud(v1)
	print v3
	
	o/p:
	[49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10]
	[49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10]
-------------------------------------------------------------------------------------
3. Write a Python program to create a 3x3 matrix with values ranging from 0 to 8
	An.
		v4 = np.arange(9)
		v4.resize(3,3)
		print v4
		v5 = np.arange(9)
		v5.shape = (3,3)
		print v5

	o/p:
	[[0 1 2]
	 [3 4 5]
	 [6 7 8]]
	[[0 1 2]
	 [3 4 5]
	 [6 7 8]]

-------------------------------------------------------------------------------------
4. Write a Python program to find indices of non-zero elements from [1,2,0,0,4,0]
	An.
		v6 = np.array([1,2,0,0,4,0])
		print v6[v6 > 0]
		
	o/p:
	[1 2 4]
-------------------------------------------------------------------------------------
5. Write a Python program to create a 3x3x3 array with random values
	An.
		v7 = np.random.rand(3,3,3)
		print v7

	o/p:
	[[[ 0.59786142  0.81538143  0.22347756]
	  [ 0.80334621  0.70418597  0.32633746]
	  [ 0.6720137   0.75557153  0.67313859]]

	  [[ 0.24118707  0.26183617  0.14846453]
	  [ 0.0092293   0.37917318  0.03625721]
	  [ 0.09914236  0.58237545  0.66817882]]

	  [[ 0.20724756  0.7963557   0.49159089]
	  [ 0.40321176  0.56961252  0.54067377]
	  [ 0.66085812  0.57027745  0.20290528]]]
-------------------------------------------------------------------------------------
6. Write a Python program to create a 10x10 array with random values and find the minimum and maximum values
	An.
		v8 = np.random.rand(10,10)
		print v8
		print ("max in the matrix: ",np.amax(v8))
		print ("min in the matrix: ",np.amin(v8))
		print ("columnwise max: ",np.amax(v8,axis=0))  #columnwise
		print ("rowwise max: ",np.amax(v8,axis=1))  #rowwise

	o/p:
	('max in the matrix: ', 0.98858651215471849)
	('min in the matrix: ', 0.0089890771702425543)
	('columnwise max: ', array([ 0.93689132,  0.77057723,  0.90345458,  0.98858651,  0.92318344,  0.91118123,  0.92464041,  0.87292738,  0.98422341,  0.86894283]))
	('rowwise max: ', array([ 0.881994  ,  0.84962667,  0.8066568 ,  0.69245293,  0.98858651,        0.90345458,  0.9125216 ,  0.85937533,  0.93689132,  0.70676257]))
-------------------------------------------------------------------------------------
7. Write a Python program to create a 5x5 matrix with row values ranging from 0 to 4
	An.
		v9 = np.arange(5)
		v10 = np.stack((v9,v9),0)
		v11 = np.stack((v9,v9),0)
		v12 = np.stack((v10,v11),0)
		v12 =  np.resize(v12,(4,5))
		v12 = np.insert(v12,1,v9,axis=0)
		print (v12)
		print ("\n")
		
		OR
		x = np.zeros((5,5))
		print("Original array:")
		print(x)
		print("Row values ranging from 0 to 4.")
		x += np.arange(5)
		print(x)

	o/p:
	[[0 1 2 3 4]
	 [0 1 2 3 4]
	 [0 1 2 3 4]
	 [0 1 2 3 4]
	 [0 1 2 3 4]]
-------------------------------------------------------------------------------------
8. Write a Python program to find the nearest value from a given value in an array.

	An.
		v13 = np.array([55,54,49,45,56])
		v14 = np.sort(v13)
		num = 50
		print ("sorted array",v14)
		v15 = np.abs(np.subtract(v14,num))
		print v15
		min_dist = np.amin(v15)
		print min_dist
		arr_pos =  np.where(v15 == min_dist)
		print v14[arr_pos]
		
	o/p: 
		('sorted array', array([45, 49, 54, 55, 56]))
		[5 1 4 5 6]
		1
		[49]
-------------------------------------------------------------------------------------
9. Write a Python program to find whether two random arrays A and B are equal.

An.
	2 1-D arrays with equal elements,
		a1 = np.array([10,20,30,40,50,44])
		a2 = np.array([10,20,30,40,50,44])
		print np.array(a1 == a2).all()

	o/p: True

	2 1-D arrays with un-equal elements,
		a1 = np.array([10,20,30,40,50,44])
		a2 = np.array([10,20,30,40,50,41])
		print np.array(a1 == a2).all()

	o/p: False
-------------------------------------------------------------------------------------
10. Consider the vector [1, 2, 3, 4, 5], write a Python program to build a new vector with three consecutive zeros interleaved between each value.
-------------------------------------------------------------------------------------
11. Write a Python program to find the most frequent value in an array.
An.
	v16 = np.array([1,2,3,1,2,1,1,1,3,2,2,1])
	counts = np.bincount(v16)
	print counts
	print np.argmax(counts)
	
	o/p: 
	[0 6 4 2]
	1
	6



