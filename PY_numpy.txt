http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-2-Numpy.ipynb

----------------------------------
NumPy stands for Numerical Python is a library consisting of multidimensional array objects and functions to process them

NumPy is often used along with packages like SciPy (Scientific Python) and Mat-plotlib (plotting library) for technical computing (Matlab can also be used for same)

Using NumPy, a developer can perform the following operations -
a) Mathematical and logical operations on arrays.
b) Fourier transforms and routines for shape manipulation.
c) Operations related to linear algebra. NumPy has in-built functions for linear algebra and random number generation.

Note: Standard Python distribution doesn't come bundled with NumPy module. A lightweight alternative is to install NumPy using popular Python package installer, pip.
      pip install numpy
	  
----------------------------
ndarray: N-dimensional array is array of items of the same type.Items in the collection can be accessed using a zero-based index.
         Each element in ndarray is an object of data-type object (called dtype).
		 ndarrays are usually of fixed size and can be multidimensional. 
		 
		 In a NumPy array, the number of dimensions is called the rank, and each dimension is called an axis. 
		 So the rows are the first axis, and the columns are the second axis.
		 
		 NOTE: One of the limitations of NumPy is that all the elements in an array have to be of the same type
		 
axis explained with examples,
2 dimensional arrays:
	x = np.array([[1, 2, 3], [4,5,6],[7,8,9]], np.int32)

	O/p: 
	array([[1, 2, 3],
		   [4, 5, 6],
		   [7, 8, 9]], dtype=int32)

	x.sum(axis=0)  
	# sum the columns [1,4,7] = 12, [2,5,8] = 15 [3,6,9] = 18  
	array([12, 15, 18])

	x.sum(axis=1)    
	# sum the rows [1,2,3] = 6, [4,5,6] = 15 [7,8,9] = 24
	array([ 6, 15, 24])

3 dimentional arrays:
	x = np.array((((1,2), (3,4) ), ((5,6),(7,8))))
	O/p:
	array([[[1, 2],
		   [3, 4]],
		  [[5, 6],
		   [7, 8]]])
	x.shape 
	# dimensions of the array : (2, 2, 2)

	x.sum(axis=0)   i.e. sum of 
	# O/p:
	array([[ 6,  8],   #  [1,5] = 6 [2,6] = 8 [3,7] = 10 [4, 8] = 12
		  [10, 12]])
		  
	x.sum(axis=1)   i.e. columns
	# O/p:
	array([[ 4,  6],   # [1,3] = 4 [2,4] = 6 [5, 7] = 12 [6, 8] = 14
		   [12, 14]])
		   
	x.sum(axis=2)   i.e. rows 
	# O/p: 
	[1, 2] = 3 [3, 4] = 7 [5, 6] = 11 [7, 8] = 15

	array([[ 3,  7],
		   [11, 15]])

	x.ndim # number of dimensions of the array
	3

-	
The basic ndarray is created using,
1) numpy.array.
	example-1,
	import numpy as np 
	a = np.array([1,2,3])     //NOTE, this format ([]) is important. () will not work. 
	print a  //o/p: [1, 2, 3]
	
	example-2,
	import numpy as np 
	a = np.array([[1, 2], [3, 4]]) 
	print a  
	
	//o/p: [[1, 2] 
			[3, 4]]
			
2) numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)
	where,
	a) object: any sequence or nested sequence
	b) dtype: desired data type of the array. THIS IS OPTIONAL
	c) copy: for copying the object. By default, it is "True". ALSO OPTIONAL
	d) order: has 3 values, A -> any (DEFAULT), C -> row major, F -> column major
	e) subok
	f) ndmin: specifies minimum dimensions of the resultant array.
	
	example-1,
		import numpy as np 
		a = np.array([1, 2, 3,4,5], ndmin = 2) 
		print a
		
		o/p:
		[[1, 2, 3, 4, 5]]
	
	example-2,
		import numpy as np 
		a = np.array([1, 2, 3], dtype = complex) 
		print a
		
		o/p:
		[ 1.+0.j,  2.+0.j,  3.+0.j]


the number of dimensions and items in an array is defined by its shape, which is a tuple of N positive integers that specify the sizes of each dimension. example,
//A 2-dimensional array of size 2 x 3, composed of 4-byte integer elements
x = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
type(x)  //o/p: <type 'numpy.ndarray'>

x.shape  //o/p: (2, 3)

x.dtype  //o/p: dtype('int32')

-----------------------------------------
Data Types:

NumPy stores values using its own data types, which are distinct from Python types like float and str. 
This is because the core of NumPy is written in a programming language called C, which stores data differently than the Python data types. 
NumPy data types map between Python and C, allowing us to use NumPy arrays without any conversion hitches.

bool_    : for boolean
int8     : Byte (-128 to 127)
int16    : Integer (-32768 to 32767)
int32    : Integer (-2147483648 to 2147483647)
int64    : Integer (-9223372036854775808 to 9223372036854775807)
uint8    : Unsigned integer (0 to 255)
uint16   : Unsigned integer (0 to 65535)
uint32   : Unsigned integer (0 to 4294967295)
uint64   : Unsigned integer (0 to 18446744073709551615)
float16  : Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
float32  : Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
float64  : Double precision float
complex64: two 32-bit floats 
complex128: two 64-bit floats
int_      : default integer type. used for int32 or int64
float_    : Shorthand for float64

dtype: i.e data type object
dtype are arrays which can have combinations of fundamental data types. This is different from numpy arrays as numpy arrays only store fundamental numeric data types (int and float).

dtype allows us to create structured arrays (i.e. "record arrays")
example, 
Country			Population Density		Area		Population
Netherlands 	393 					41526 		16,928,800 
Belgium 		337 					30510 		11,007,020 
United Kingdom 	256 					243610 		62,262,000 

example of dtype,
	import numpy as np
	i16 = np.dtype(np.int16)			//We define an int16 
	print(i16)
	lst = [ [3.4, 8.7, 9.9], 
			[1.1, -7.8, -0.7],
			[4.1, 12.3, 4.8] ]
	A = np.array(lst, dtype=i16)       //The elements of the list 'lst' are turned into i16 types to create the two-dimensional array A.
	print(A)
	
	o/p:
	int16
	[[ 3  8  9]
	 [ 1 -7  0]
	 [ 4 12  4]]

A dtype object is constructed using the following syntax -
numpy.dtype(object, align, copy)
where,
	Object - To be converted to data type object
	Align  - If true, adds padding to the field to make it similar to C-struct
	Copy   - Makes a new copy of dtype object. If false, the result is reference to builtin data type object

built in data type short hand,
'b' - boolean
'i' - (signed) integer
'u' - unsigned integer
'f' - floating-point
'c' - complex-floating point
'm' - timedelta
'M' - datetime
'O' - (Python) objects
'S', 'a' - (byte-)string
'U' - Unicode
'V' - raw data (void)

creating structured arrays via datatype,
reconsider the example using,
Country			Population Density		Area		Population
Netherlands 	393 					41526 		16,928,800 
Belgium 		337 					30510 		11,007,020 
United Kingdom 	256 					243610 		62,262,000 

import numpy as np
dt = np.dtype([('density', np.int32)])
x = np.array([(393,), (337,), (256,)],dtype=dt)
print(x) 
print("\nThe internal representation:")
print(repr(x))
print(x['density'])    //access the content of density column.

o/p,
[(393,) (337,) (256,)]
The internal representation:
array([(393,), (337,), (256,)],
      dtype=[('density', '<i4')])
[393 337 256]

same example with data type short hand,
dt = np.dtype([('density', 'i4')])       //here, The 'i' means integer and the 4 means 4 bytes
x = np.array([(393,), (337,), (256,)],
             dtype=dt)
print(x)                                 //o/p: [(393,) (337,) (256,)]


What is less-than sign in front of i4 in the result?
'<' - means that the encoding will be little-endian.
'>' - means that the encoding will be big-endian.
no Prefix - native byte ordering.

example,
# little-endian ordering
dt = np.dtype('<d')
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 = 8
# big-endian ordering
dt = np.dtype('>d')  
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 > 8
# native byte ordering
dt = np.dtype('d') 
print(dt.name, dt.byteorder, dt.itemsize)  //o/p: float64 = 8

example, (to define the entire dataset)
dt = np.dtype([('country', 'S20'), ('density', 'i4'), ('area', 'i4'), ('population', 'i4')])
population_table = np.array([
    ('Netherlands', 393, 41526, 16928800),
    ('Belgium', 337, 30510, 11007020),
    ('United Kingdom', 256, 243610, 62262000)],dtype = dt)
print ( population_table )
print ("\n")
print ( population_table[:1])
print(population_table['density'])
print(population_table['country'])
print(population_table['area'][:2])

o/p:
[(b'Netherlands', 393,  41526, 16928800)
 (b'Belgium', 337,  30510, 11007020)
 (b'United Kingdom', 256, 243610, 62262000)]
 
[(b'Netherlands', 393,  41526, 16928800)]

[393 337 256]
[b'Netherlands' b'Belgium' b'United Kingdom']
[41526,30510]


Datatype explicit conversion:
numpy.ndarray.astype is used for explicit conversion.
example, 
wines.astype(int)

dt = np.dtype([('density', np.float32)])
x = np.array([(393,), (337,), (256,)],dtype=dt)
print(x['density'])    //access the content of density column.
int_x = x.astype(int32)
print (int_x['density'])

o/p,
[393.0 337.0 256.0]
[393 337 256]

-------------------------------------------------------------
Array Attributes:
1) ndarray.shape: returns a tuple consisting of array dimensions
	example,
		import numpy as np 
		a = np.array([[1,2,3],[4,5,6]]) 
		print (a.shape)                     //re-sizes the ndarray 
		b = np.array([[1,2,3],[4,5,6]])
		b.shape = (3,2)
		print (b)
		c = a.reshape(3,2)               //re-size function to resize an array. 
		print (c)
		
	o/p:
	(2, 3)
	[[1, 2] 
	 [3, 4] 
	 [5, 6]]
	[[1, 2] 
	 [3, 4] 
	 [5, 6]]
	 
2) arange: returns an array with predefined range.
	example,
		import numpy as np 
		a = np.arange(24)     //Note: the range will start with 0 
		print (a)
		b = a.reshape(2,4,3)  //3 dimensional array
		print (b)
		
		
	o/p: 
	[0 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16 17 18 19 20 21 22 23]
	[[[ 0,  1,  2] 
	  [ 3,  4,  5] 
	  [ 6,  7,  8] 
	  [ 9, 10, 11]]  
	  [[12, 13, 14] 
	   [15, 16, 17]
	   [18, 19, 20] 
    [21, 22, 23]]] 
	
3) ndarray.ndim: returns the number of array dimensions.
	example,
		import numpy as np 
		a = np.arange(24)     //Note: the range will start with 0 
		print (a.ndim)
		b = a.reshape(2,4,3)  //3 dimensional array
		print (b.ndim)
		
	o/p:
	1
	3

4) numpy.itemsize: returns the length of each element of array in bytes.
	example,
		# dtype of array is int8 (1 byte) , float32 (4 bytes)
		import numpy as np 
		x = np.array([1,2,3,4,5], dtype = np.int8) 
		print x.itemsize
		y = np.array([1,2,3,4,5], dtype = np.float32)
		print y.itemsize
		
	o/p: 
	1
	4
	
---------------------------------------------------------------------
Array Creation Routines:
A new ndarray object can be created and initialized via,
1) numpy.empty: creates an uninitialized array of specified shape and dtype
	Syntax: numpy.empty(shape, dtype = float, order = 'C')
			where Order -> 'C' for C-style row-major array, 'F' for FORTRAN style column-major array.
			
	example,
	import numpy as np 
	x = np.empty([3,2], dtype = int) 
	print x

	o/p, will be random values as,
	[[22649312    1701344351] 
	 [1818321759  1885959276] 
	 [16779776    156368896]]
	 
2) numpy.zeros: creates a new array of specified size, filled with zeroes.

	example1,
	# array of five zeros. Default dtype is float 
	import numpy as np 
	x = np.zeros(5) 
	print x
	
	o/p, [ 0.  0.  0.  0.  0.]
	
	example2,
	# custom type 
	import numpy as np 
	x = np.zeros((2,2), dtype = [('x', 'i4'), ('y', 'i4')])  
	print x
	
	o/p:
	[[(0,0)(0,0)]
	[(0,0)(0,0)]] 
	
3) numpy.ones: similar to numpy.zeroes except arrays are filled with ones.
------------------------------------------------------------
Array From Existing Data (ex, array, tuples etc)

1) numpy.asarray: 
	example 1,
		import numpy as np 
		x = [1,2,3] 
		a = np.asarray(x) 
		print a
		
	o/p: [1  2  3]
	
	example 2,
		import numpy as np 
		x = [1,2,3]
		a = np.asarray(x, dtype = float) 
		print a
		
	o/p: [ 1.  2.  3.] 
	
	example 3,
		import numpy as np 
		x = (1,2,3) 
		a = np.asarray(x) 
		print a
		
	o/p: [1  2  3]
	
2) numpy.frombuffer: interprets a buffer as one-dimensional array.
	syntax: numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)
			where,
			count : The number of items to read, default -1 means all data
			offset: The starting position to read from. Default is 0
			
	example,
		import numpy as np 
		s = 'Hello World' 
		a = np.frombuffer(s, dtype = 'S1') 
		print a
	
	o/p: ['H'  'e'  'l'  'l'  'o'  ' '  'W'  'o'  'r'  'l'  'd']
	
	
3) numpy.fromiter: This function builds a new ndarray object from any iterable object.
	example,
		import numpy as np 
		list = range(5) 
		it = iter(list)  
		# use iterator to create ndarray 
		x = np.fromiter(it, dtype = float) 
		print x

	o/p: [0.   1.   2.   3.   4.]
	
4) numpy.arange: create an array from numerical ranges.
	syntax, numpy.arange(start, stop, step, dtype)
			where,
			start -> The start of an interval. If omitted, defaults to 0
			stop  -> The end of an interval (not including this number)
			step  -> Spacing between values, default is 1
			
	example,
		import numpy as np
		x = np.arange(5)      //arange will skip the "stop" value, i.e. in this case, it is 5, so x will be [1 2 3 4]
		print x
		y = np.arange(5, dtype = float)
		print y
		z = np.arange(10,20,2)   //will skip "20" i.e. stop value.
		print z

	o/p:
	[0  1  2  3  4]
	[0.  1.  2.  3.  4.] 
	[10  12  14  16  18]
	
---------------------------------------------------------------------------
Indexing & Slicing:

used to access and modify ndarrays. There are three types of indexing methods are available - 
field access 
basic slicing
advanced indexing.

example 1,
	import numpy as np 
	a = np.arange(10) 
	s = slice(2,7,2)    //i.e. start, stop, and step 
	print a[s]
	b = a[2:7:2] 
	print b
	c = a[5] 
	print c
	print a[2:]
	print a[2:5]
	z = np.array([[1,2,3],[3,4,5],[4,5,6]]) 
	print z
	print 'Now we will slice the array from the index a[1:]' 
	print a[1:]
	
	o/p: 
	[2  4  6]
	[2  4  6]
	5
	[2  3  4  5  6  7  8  9]
	[2  3  4]
	[[1 2 3]
	 [3 4 5]
	 [4 5 6]]
	Now we will slice the array from the index a[1:]
	[[3 4 5]
	 [4 5 6]]
	
example 2,
	# array to begin with 
	import numpy as np 
	a = np.array([[1,2,3],[3,4,5],[4,5,6]]) 

	print 'Our array is:' 
	print a 
	print '\n'  

	# this returns array of items in the second column 
	print 'The items in the second column are:'  
	print a[...,1] 
	print '\n'  

	# Now we will slice all items from the second row 
	print 'The items in the second row are:' 
	print a[1,...] 
	print '\n'  

	# Now we will slice all items from column 1 onwards 
	print 'The items column 1 onwards are:' 
	print a[...,1:]
	
	o/p:
	Our array is:
	[[1 2 3]
	 [3 4 5]
	 [4 5 6]] 
	 
	The items in the second column are: 
	[2 4 5] 

	The items in the second row are:
	[3 4 5]

	The items column 1 onwards are:
	[[2 3]
	 [4 5]
	 [5 6]] 

	 
Integer Indexing,
you can select any arbitrary item in an array based on its Ndimensional index.
example 1,
	import numpy as np 
	x = np.array([[1, 2], [3, 4], [5, 6]]) 
	y = x[[0,1,2], [0,1,0]] 		//includes elements at (0,0), (1,1) and (2,0) from x	
	print y

	o/p: [1  4  5]
	
example 2, will give the corner values [COULD NOT UNDERSTAND THIS EXAMPLE]
	import numpy as np 
	x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
	print 'Our array is:' 
	print x 
	print '\n' 
	rows = np.array([[0,0],[3,3]])    //[[ 9 10 11]  [ 9 10 11]]]
	cols = np.array([[0,2],[0,2]])    //[[[0 1 2]  [6 7 8]] [[0 1 2]  [6 7 8]]]
	y = x[rows,cols] 
	print 'The corner elements of this array are:' 
	print y

	o/p,
	Our array is:                                                                 
	[[ 0  1  2]                                                                   
	 [ 3  4  5]                                                                   
	 [ 6  7  8]                                                                   
	 [ 9 10 11]]
	 
	The corner elements of this array are:                                        
	[[ 0  2]                                                                      
	 [ 9 11]] 
	 
	 
Slicing an array:
example,
	import numpy as np 
	x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
	print 'Our array is:' 
	print x 
	print '\n'  
	# slicing 
	z = x[1:4,1:3]     //AS IT WILL IGNORE THE LAST ELEMENT, i.e. it will consider 1:3,1:2
	print 'After slicing, our array becomes:' 
	print z 
	print '\n'  
	# using advanced index for column 
	y = x[1:4,[1,2]] 
	print 'Slicing using advanced index for column:' 
	print y
	
	o/p:
	Our array is:
	[[ 0  1  2] 
	 [ 3  4  5] 
	 [ 6  7  8]
	 [ 9 10 11]]
	 
	After slicing, our array becomes:
	[[ 4  5]
	 [ 7  8]
	 [10 11]]

	Slicing using advanced index for column:
	[[ 4  5]
	 [ 7  8]
	 [10 11]]

	 
Boolean array indexing:
This indexing is used when the resultant object is meant to be the result of Boolean operations, such as comparison operators.

example 1,
	import numpy as np 
	a = np.array([1,2,10,11,4]) 
	print a[a > 5]

	O/p: [10,11]
	
example 2,
	import numpy as np 
	a = np.array([np.nan, 1,2,np.nan,3,4,5]) 
	print a[~np.isnan(a)]

	O/p: [ 1.   2.   3.   4.   5.] 
	
example 3,
	import numpy as np 
	a = np.array([1, 2+6j, 5, 3.5+5j]) 
	print a[np.iscomplex(a)]

O/p: [2.0+6.j  3.5+5.j] 
------------------------------------------------------------------------------------------------
Broadcasting,

Arithmetic operations on arrays are usually done on corresponding elements i.e. the 2 arrays should be of same size.

example,
	import numpy as np 
	a = np.array([1,2,3,4]) 
	b = np.array([10,20,30,40]) 
	c = a * b 
	print c

	o/p:
	[10   40   90   160]
	
Broadcasting in Numpy allows operations on arrays of non-similar shapes.
i.e. The smaller array is broadcast to the size of the larger array so that they have compatible shapes.

Broadcasting is possible on following cases:
1) Array with smaller dimension is prepended with 1.
2) Dimension of o/p array is same as the i/p array with bigger dimension.
3) If the dimension lengths aren't equal, and none of the dimensions have length 1, then there's an error.
4) If an input has a dimension size of 1, the first data entry in that dimension is used for 
	all calculations along that dimension.
	
example,
	import numpy as np 
	a = np.array([[0.0,0.0,0.0],[10.0,10.0,10.0],[20.0,20.0,20.0],[30.0,30.0,30.0]])     //shape (4,3)
	b = np.array([1.0,2.0,3.0])                                                          //shape (3,)
	# 
	print 'First array:' 
	print a 
	print '\n'  
	#  
	print 'Second array:' 
	print b 
	print '\n'  
	#  
	print 'First Array + Second Array' 
	print a + b
	
O/p:
First array:
[[ 0. 0. 0.]
 [ 10. 10. 10.]
 [ 20. 20. 20.]
 [ 30. 30. 30.]]

Second array:
[ 1. 2. 3.]

First Array + Second Array
[[ 1. 2. 3.]
 [ 11. 12. 13.]
 [ 21. 22. 23.]
 [ 31. 32. 33.]]

The following shapes are compatible, 
1) A: (50,3) & B: (3,) although B is then out of elements
	BUT the length of the trailing dimension of array A is 3, and the length of the trailing dimension of array B is 3
	They're equal, so that dimension is okay.

2) A: (1,2) & B: (50,2) The last dimension matches, and A is of length 1 in the first dimension.

The following shapes are not compatible,
1) A: (50,50) & B: (49,49) The lengths of the dimensions aren't equal, and neither array has either dimension length equal to 1.

	
----------------------------------------------------------------
Iterating Over Array:

a) numpy.nditer is an efficient multidimensional iterator object using which it is possible to iterate over an array.

example 1,
	import numpy as np
	a = np.arange(0,60,5)
	print 'Original array is:'
	print a
	a = a.reshape(3,4)
	print a
	for x in np.nditer(a):
	   print x,

	o/p:
	[ 0  5 10 15 20 25 30 35 40 45 50 55]

	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]
	 
	0 5 10 15 20 25 30 35 40 45 50 55
	
example 2, (transposing an array)
	import numpy as np 
	a = np.arange(0,60,5) 
	a = a.reshape(3,4) 
	   
	print 'Original array is:'
	print a 
	print '\n'  
	   
	print 'Transpose of the original array is:' 
	b = a.T 
	print b 
	print '\n'  
	   
	print 'Modified array is:' 
	for x in np.nditer(b): 
	   print x,

o/p:
Original array is:
[[ 0 5 10 15]
 [20 25 30 35]
 [40 45 50 55]]

Transpose of the original array is:
[[ 0 20 40]
 [ 5 25 45]
 [10 30 50]
 [15 35 55]]

Modified array is:
0 5 10 15 20 25 30 35 40 45 50 55

b) Iteration Order
	a) if elements are stored using C-style order, the iterator iterates row wise.
	b) if elements are stored using F-style order, the iterator iterates column wise.
	
example,
	import numpy as np
	a = np.arange(0,60,5)
	a = a.reshape(3,4)
	print 'Original array is:'
	print a
	print '\n'

	print 'Transpose of the original array is:'
	b = a.T
	print b
	print '\n'

	print 'Sorted in C-style order:'
	c = b.copy(order='C')
	print c
	for x in np.nditer(c):
	   print x,

	print '\n'

	print 'Sorted in F-style order:'
	c = b.copy(order='F')
	print c
	for x in np.nditer(c):
	   print x,
	   
o/p:
	Original array is:
	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]

	Transpose of the original array is:
	[[ 0 20 40]
	 [ 5 25 45]
	 [10 30 50]
	 [15 35 55]]

	Sorted in C-style order:
	[[ 0 20 40]
	 [ 5 25 45]
	 [10 30 50]
	 [15 35 55]]
	0 20 40 5 25 45 10 30 50 15 35 55

	Sorted in F-style order:
	[[ 0 20 40]
	 [ 5 25 45]
	 [10 30 50]
	 [15 35 55]]
	0 5 10 15 20 25 30 35 40 45 50 55
	
----------------------------------------------------------------------------------------------------------
Modifying array values:

nditer can also be used to modify array values with optional parameter called "op_flags".
op_flags values are,
1) Its default value is read-only, 
2) To enable modifying array elements with,
	a) read-write 
	b) write-only mode.

for instance, "np.nditer(a, op_flags=['readwrite'])"

example,
	import numpy as np
	a = np.arange(0,60,5)
	a = a.reshape(3,4)
	print 'Original array is:'
	print a
	print '\n'

	for x in np.nditer(a, op_flags=['readwrite']):
	   x[...]=2*x
	print 'Modified array is:'
	print a
	
o/p:
	Original array is:
	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]

	Modified array is:
	[[ 0 10 20 30]
	 [ 40 50 60 70]
	 [ 80 90 100 110]]
	 

Broadcasting Iteration:
i.e. combined nditer object is able to iterate thru multiple arrays concurrently as,

example,
	import numpy as np 
	a = np.arange(0,60,5) 
	a = a.reshape(3,4) 
	#
	print 'First array is:' 
	print a 
	print '\n'  
	#
	print 'Second array is:' 
	b = np.array([1, 2, 3, 4], dtype = int) 
	print b  
	print '\n' 
	#
	print 'Modified array is:' 
	for x,y in np.nditer([a,b]): 
	   print "%d:%d" % (x,y),
	   
o/p:
	First array is:
	[[ 0 5 10 15]
	 [20 25 30 35]
	 [40 45 50 55]]

	Second array is:
	[1 2 3 4]

	Modified array is:
	0:1 5:2 10:3 15:4 20:1 25:2 30:3 35:4 40:1 45:2 50:3 55:4
	 
----------------------------------------------------------------------------------------------------------
Array Manipulation:

1) changing shape (dimensions) of the array. 
	a) reshape,
		example,
			import numpy as np
			a = np.arange(8)
			print 'The original array:'
			print a
			print '\n'
			#
			b = a.reshape(4,2)
			print 'The modified array:'
			print b
	
		o/p:
		[0 1 2 3 4 5 6 7]
		The modified array:
		[[0 1]
		 [2 3]
		 [4 5]
		 [6 7]]
		 
	b) flatten, returns a copy of an array collapsed into one dimension.
		example,
			import numpy as np 
			a = np.arange(8).reshape(2,4) 
			#
			print 'The original array is:' 
			print a 
			print '\n'  
			# default is column-major 
			print 'The flattened array is:' 
			print a.flatten() 
			print '\n'  
			print 'The flattened array in F-style ordering:' 
			print a.flatten(order = 'F')
			
		o/p:
			The original array is:
			[[0 1 2 3]
			 [4 5 6 7]]

			The flattened array is:
			[0 1 2 3 4 5 6 7]

			The flattened array in F-style ordering:
			[0 4 1 5 2 6 3 7]
			
	c) ravel: returns a flattened one-dimensional array. A copy is made only if needed.
		example,
			import numpy as np 
			a = np.arange(8).reshape(2,4) 
			#
			print 'The original array is:' 
			print a 
			print '\n'  
			#
			print 'After applying ravel function:' 
			print a.ravel()  
			print '\n' 
			#
			print 'Applying ravel function in F-style ordering:' 
			print a.ravel(order = 'F')
			
		o/p:
		The original array is:
		[[0 1 2 3]
		 [4 5 6 7]]

		After applying ravel function:
		[0 1 2 3 4 5 6 7]

		Applying ravel function in F-style ordering:
		[0 4 1 5 2 6 3 7]
		
2) Transpose Operations: 
	a) transpose: permutes the dimension of the given array.
	   example,
			import numpy as np 
			a = np.arange(12).reshape(3,4) 
			print 'The original array is:' 
			print a  
			print '\n' 
			print 'The transposed array is:' 
			print np.transpose(a)
		
		o/p:
		The original array is:
		[[ 0 1 2 3]	
		 [ 4 5 6 7]
		 [ 8 9 10 11]]

		The transposed array is:
		[[ 0 4 8]
		 [ 1 5 9]
		 [ 2 6 10]
		 [ 3 7 11]]
		 
	b) ndarray.T: same functionality as transpose,
		example,
			a = np.arange(12).reshape(3,4)
			print a.T
		
		o/p: same as transpose.
		
3) Joining Arrays:
	a) numpy.concatenate:
		example,
			import numpy as np 
			a = np.array([[1,2],[3,4]]) 
			#
			print 'First array:' 
			print a 
			print '\n'  
			b = np.array([[5,6],[7,8]]) 
			#
			print 'Second array:' 
			print b 
			print '\n'  
			# both the arrays are of same dimensions 
			print 'Joining the two arrays along axis 0:' 
			print np.concatenate((a,b)) 
			print '\n'  
			print 'Joining the two arrays along axis 1:' 
			print np.concatenate((a,b),axis = 1)
			
		o/p:
			First array:
			[[1 2]
			 [3 4]]

			Second array:
			[[5 6]
			 [7 8]]

			Joining the two arrays along axis 0:
			[[1 2]
			 [3 4]
			 [5 6]
			 [7 8]]

			Joining the two arrays along axis 1:
			[[1 2 5 6]
			 [3 4 7 8]]
			 
	b) numpy.stack: 
----------------------------------------------------------------------------------------------------------
Numpy operation in csv or text file.

numpy.genfromtxt function can be used to directly read csv or other files into arrays.
example,
wines = np.genfromtxt("winequality-red.csv", delimiter=";", skip_header=1)

o/p: array([[  7.4  ,   0.7  ,   0.   , ...,   0.56 ,   9.4  ,   5.   ],
       [  7.8  ,   0.88 ,   0.   , ...,   0.68 ,   9.8  ,   5.   ],
       [  7.8  ,   0.76 ,   0.04 , ...,   0.65 ,   9.8  ,   5.   ],
       ..., 
       [  6.3  ,   0.51 ,   0.13 , ...,   0.75 ,  11.   ,   6.   ],
       [  5.9  ,   0.645,   0.12 , ...,   0.71 ,  10.2  ,   5.   ],
       [  6.   ,   0.31 ,   0.47 , ...,   0.66 ,  11.   ,   6.   ]])

 

