refer: http://a4academics.com/interview-questions/57-c-plus-plus/720-c-interview-questions-experienced

C Programming interview questions:

What is a pointer on pointer? int x = 5, *p=&x, **q=&p.
Distinguish between malloc() & calloc() memory allocation?
What is keyword auto for? auto is a modifier like static. It defines the storage class of a variable
	1) By default every local variable of the function is automatic (auto). 
	2)  A global variable can’t be an automatic variable.
		example,
			void f() {
			   int i;
			   auto int j;
			} /* both i and j are declared auto.
What is difference between including the header file with-in angular braces < > and double quotes “ “?
	1) < > then the compiler searches for the particular header file only with in the built in include path.
	2) “ “, then the compiler searches for the particular header file first in the current working directory then in "Include" path.
How a negative integer is stored?
	it is stored with 2's complement. (i.e. 5 is 0101)
	Step-1 - One’s compliment of 5 : 1010
	Step-2 - Add 1 to above, giving 1011, which is -5
What is a static variable? 
	1) A static variable inside a function keeps its value between invocations.
		example, we can use static int to count number of times a function is called.
			#include<stdio.h>
			int fun()
			{
			  static int count = 0;
			  count++;
			  return count;
			}  
			int main()
			{
			  printf("%d ", fun());
			  printf("%d ", fun());
			  return 0;
			}
		o/p : 1 2
		had it been int count = 0, the o/p would have been 1 1
	2) Static variables (like global variables) are initialized as 0 if not initialized explicitly. This hold true for any data type.
	3)  In C, static variables can only be initialized using constant literals. The following program will error.
			#include<stdio.h>
			int initializer(void)
			{
				return 50;
			}
			int main()
			{
				static int i = initializer();
				printf(" value of i = %d", i);
				getchar();
				return 0;
			}

			o/p: 9:5: error: initializer element is not constant.
			
What is the purpose of extern storage specifier? 
	extern tells the compiler that this data is defined somewhere and will be connected with the linker.
	example,
	/* the following program will error */
		extern int var;
		int main(void)
		{
		 var = 10;
		 return 0;
		} /*This program throws error in compilation. Because var is declared but not defined anywhere. */
		
	to correct this,
		#include "somefile.h"
		extern int var;
		int main(void)
		{
		 var = 10;
		 return 0;
		} /*Supposing that somefile.h has the definition of var. This program will be compiled successfully.*/

	also,
		extern int var = 0;
		int main(void)
		{
		 var = 10;
		 return 0;
		} /* will be successful. As,an initializer is also provided with that declaration, then the memory for that variable will be allocated.
		
Explain the purpose of the function sprintf()? Prints the formatted output onto the character array.

When should we use the register storage specifier? 
	If a variable is used most frequently then it should be declared using register storage specifier, then possibly the compiler gives CPU register for its 
	storage to speed up the look up of the variable.
	
	********************************************************
	4 storage class specifiers available in C language:

	Storage Specifier 	Description
	auto 				Storage place: CPU Memory
						 Initial/default value: Garbage value
						 Scope: local
						 Life: Within the function only. 
	extern 				Storage place: CPU memory
						 Initial/default value: Zero
						 Scope: Global
						 Life: Till the end of the main program. Variable definition might be anywhere in the C program. 

    static				Storage place: CPU memory
						 Initial/default value: Zero
						 Scope: local
						 Life: Retains the value of the variable between different function calls.
 
    register			Storage place: Register memory
						 Initial/default value: Garbage value
						 Scope: local
						 Life: Within the function only. 

	
	register variables are stored in register memory whereas auto variables are stored in main CPU memory.
	example,
		#include <stdio.h>
		int main()
		{
			register int i;
			int arr[5] = {1,2,3,4,5};
			for (i=0; i< 5;i++)
			{
				printf("Value = <%d>\n", arr[i])
			}
		}
	********************************************************	
S++ or S = S+1, which can be recommended to increment the value by 1 and why? S++, as it is single machine instruction (INC) internally.

What is a dangling pointer? A pointer initially holding valid address, but later the held address is released or freed. Then such a pointer is called as dangling pointer. 
	example,
			int main()
			{
				int *ptr = (int *)malloc(sizeof(int));
				// After below free call, ptr becomes a dangling pointer
				free(ptr); 
				// No more a dangling pointer
				ptr = NULL;
			}
	
	another example,
			// The pointer pointing to local variable becomes
			// dangling when local variable is static.
			#include<stdio.h>
			int *fun()
			{
				// x is local variable and goes out of
				// scope after an execution of fun() is
				// over.
				int x = 5;
				return &x;
			}
			// Driver Code
			int main()
			{
				int *p = fun();
				fflush(stdin);
				// p points to something which is not
				// valid anymore
				printf("%d", *p);
				return 0;
			}
			
			o/p: A garbage Address

		to correct it,
			// The pointer pointing to local variable doesn't
			// become dangling when local variable is static.
			#include<stdio.h>
			int *fun()
			{
				// x now has scope throughout the program
				static int x = 5;
				return &x;
			}
			int main()
			{
				int *p = fun();
				fflush(stdin);
				// Not a dangling pointer as it points
				// to static variable.
				printf("%d",*p);
			}
			
			o/p: 5

		example, Variable goes out of scope,
			void main()
			{
			   int *ptr;
			   .....
			   .....
			   {
				   int ch;
				   ptr = &ch;
			   } 
			   .....   
			   // Here ptr is dangling pointer
			}	

*********************************************************
Pointer trivia,
1) Dangling pointer: covered.
2) Void Pointer: a pointer that points to some data location in storage, which doesn’t have any specific type.
				NOTE: Basically the type of data that it points to is can be any.
				a) void pointers cannot be dereferenced. It can however be done using typecasting the void pointer 
				b) Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size.
				
			When we do not know what type of the memory address the pointer variable is going to hold, then we declare a void pointer for such.
 		 
		example,
			#include<stdlib.h>
			int main()
			{
				int x = 4;
				float y = 5.5;    
				//A void pointer
				void *ptr;
				ptr = &x;
				// (int*)ptr - does type casting of void 
				// *((int*)ptr) dereferences the typecasted 
				// void pointer variable.
				printf("Integer variable is = %d", *( (int*) ptr) );

				// void pointer is now float
				ptr = &y; 
				printf("\nFloat variable is= %f", *( (float*) ptr) );
			 
				return 0;
			}
			
		o/p:
			Integer variable is = 4
			Float variable is= 5.500000
			
3) NULL Pointer:
		a) NULL vs Uninitialized pointer –  An uninitialized pointer stores an undefined value. A null pointer stores a defined value, but one that is 
		defined by the environment to not be a valid address for any member or object.
		b) NULL vs Void Pointer – Null pointer is a value, while void pointer is a type.
		
		example,
			#include <stdio.h>
			int main()
			{
				// Null Pointer
				int *ptr = NULL;   
				printf("The value of ptr is %u", ptr);
				return 0;
			}
			
		o/p: The value of ptr is 0.

		
4) Wild Pointer:
	A pointer which has not been initialized to anything (not even NULL) is known as wild pointer. 
	The pointer may be initialized to a non-NULL garbage value that may not be a valid address.
	example,
		int main()
		{
			int *p;  /* wild pointer */ 
			int x = 10;
			// p is not a wild pointer now
			p = &x;
			return 0;
		}

*********************************************************

What is the purpose of the keyword typedef? It is used to alias the existing type. Also used to simplify the complex declaration of the type.
		example,
		 struct x1 {
			int i;
			char x[10]
			};
			
		 typedef struct x1 emp1;
		 
What is lvalue and rvalue? The expression appearing on right side of the assignment operator is called as rvalue. Rvalue is assigned to lvalue, which appears on left side of the assignment operator. The lvalue should designate to a variable not a constant.

Can a program be compiled without main() function? it can be compiled but not executed.

Where an automatic variable is stored? Every local variable by default being an auto variable is stored in stack memory.
	
What is the difference between variable declaration and variable definition? Declaration associates type to the variable whereas definition gives the value to the variable.

What is a self-referential structure? A self-referential structure is one of the data structures which refer to the pointer to (points) to another structure of the same type. A linked list is an example of self-referential data structure.

	example,
		struct NODE {
					 struct NODE new;    /* 'new' declared variable */
					 int value;
			};
	    
		but, compiler can’t evaluate correctly how much storage to allocate to ‘new’ member of template struct NODE
		NOTE: member of struct NODE can’t be a variable of type struct NODE
		
		to accomplish a self refrential structure,
		struct NODE {
					 struct NODE *new;    /* 'new' a pointer-to-struct NODE */
					 int value;
			};

		here, any pointer type takes 8 bytes of storage, so it will evaluate correctly the storage requirements.
		
What is a token? token is either a keyword, an identifier, a constant, a string literal, or a symbol.

What is a preprocessor? Preprocessor is a directive to the compiler to perform certain things before the actual compilation process begins.

Does a break is required by default case in switch statement? Yes, if it is not appearing as the last case.

When to user -> (arrow) operator? 

What are bit fields? used to specify size (in bits) of structure and union members to use memory efficiently when we know the limit of the max value in a field.
	example, /*without bit fields*/ 
		#include <stdio.h>
		// A simple representation of date
		struct date
		{
		   unsigned int d;
		   unsigned int m;
		   unsigned int y;
		};
		int main()
		{
		   printf("Size of date is %d bytes\n", sizeof(struct date));
		   struct date dt = {31, 12, 2014};
		   printf("Date is %d/%d/%d", dt.d, dt.m, dt.y);
		}
		
	o/p: 
		Size of date is 12 bytes
		Date is 31/12/2014
		
	12 bytes coz each unsigned int will take 4 bytes (on 32 bit compiler)
	
	Bit fields will handle the same code as,
		#include <stdio.h>
		// A space optimized representation of date
		struct date
		{
		   // d has value between 1 and 31, so 5 bits are sufficient i.e. 31 = 11111 (5 bits) 
		   unsigned int d: 5;
		   // m has value between 1 and 12, so 4 bits are sufficient i.e. 12 = 1100 (4 bits)
		   unsigned int m: 4;
		   unsigned int y;
		};
		int main()
		{
		   printf("Size of date is %d bytes\n", sizeof(struct date));
		   struct date dt = {31, 12, 2014};
		   printf("Date is %d/%d/%d", dt.d, dt.m, dt.y);
		   return 0;
		}
		
	o/p: 
		Size of date is 8 bytes
		Date is 31/12/2014
		

What is the purpose of built-in stricmp() function? It compares two strings by ignoring the case.

Describe the file opening mode “w+”? Opens a file both for reading and writing. If a file is not existing it creates one, else if the file is existing it will be over written.

Where the address of operator (&) cannot be used? It cannot be used on constants.

Is FILE a built-in data type? Yes. Defined in stdio.h

What is reminder for 5.0 % 2? Error, It is invalid that either of the operands for the modulus operator (%) is a real number.

How many operators are there under the category of ternary operators? one operator and is conditional operator (? : ).

Which key word is used to perform unconditional branching? goto

What is a pointer to a function? A pointer holding the reference of the function is called pointer to a function.

What is a NULL statement? no executable statements such as ; example, while( ++count<=10 ) ;

What is a static function? 
	Unlike global functions in C, access to static functions is restricted to the file where they are declared. 
	reason for making functions static can be reuse of the same function name in other files.
	example,
	file1.c
			/* Inside file1.c */
			static void fun1(void)
			{
			  puts("fun1 called");
			}

	file2.c
			/* Inside file2.c  */
			int main(void)
			{
			  fun1(); 
			  getchar();
			  return 0;  
			}

	o/p: if we compile the above code with command “gcc file2.c file1.c”, it errors with “undefined reference to `fun1’”.
	
What is the problem with the following coding snippet?
	char *s1 = "hello",*s2 = "welcome";
	strcat(s1,s2);

	o/p: This will error as s1 points to a string constant and cannot be altered.
	
What are enumerations? Enumerations are list of integer constants with name.
	syntax: enum flag{constant1, constant2, constant3, ....... };
	
		#include<stdio.h> 
		enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
		int main()
		{
			enum week day;
			day = Wed;
			printf("%d",day);
			return 0;
		} 
		
	Output: 2. /*we declared “day” as the variable and the value of “Wed” is allocated to day, which is 2.*/
	
	facts,
	a) Two enum names can have same value.
			#include <stdio.h>
			enum State {Working = 1, Failed = 0, Freezed = 0};
			int main()
			{
			   printf("%d, %d, %d", Working, Failed, Freezed);
			   return 0;
			}
		o/p: 1,0,0
		
	b) the compiler by default assigns values starting from 0. example, check the week example above.
	
	c) Another example,
			#include <stdio.h>
			enum day {sunday = 1, monday, tuesday = 5, wednesday, thursday = 10, friday, saturday}; 
			int main()
			{
				printf("%d %d %d %d %d %d %d", sunday, monday, tuesday,
						wednesday, thursday, friday, saturday);
				return 0;
			}
			
		o/p: 1 2 5 6 10 11 12
		
	d) functions with return type ENUM,
			#include <stdio.h>
			enum State {WORKING = 0, FAILED, FREEZED};
			enum State currState = 2;
			enum State FindState() {
				return currState;
			}
			int main() {
			(FindState() == WORKING)? printf("WORKING"): printf("NOT WORKING");
			return 0;
			}
			
		o/p: NOT WORKING.

Which built-in function can be used to move the file pointer internally? fseek()

What it the return value of a relational operator if it returns any? Return a value 1 if the relation between the expressions is true, else 0.

What are valid operations on pointers? Comparision and Addition/Substraction (excluding void pointers)

What is a string length? It is the count of character excluding the ‘\0’ character.

What is the purpose of #def and #undef preprocessor? is used to define and undefine a macro.

What is typecasting? Typecasting is a way to convert a variable/constant from one type to another type.
	two types of type conversion:
	a) Implicit Type Conversion: Done by the compiler on its own.
		example,
			// An example of implicit conversion
			#include<stdio.h>
			int main()
			{
				int x = 10;    // integer x
				char y = 'a';  // character c 
				// y implicitly converted to int. ASCII value of 'a' is 97
				x = x + y;
				// x is implicitly converted to float
				float z = x + 1.0;
				printf("x = %d, z = %f", x, z);
				return 0;
			}

		o/p: x = 107, z = 108.000000
		
	b) Explicit Type Conversion: syntax is (type) expression
		example,
			#include<stdio.h>
			int main()
			{
				double x = 1.2;
				// Explicit conversion from double to int
				int sum = (int)x + 1;
				printf("sum = %d", sum); 
				return 0;
			}

		o/p: sum = 2
		
What is the output file generated by the linker?  Linker generates the executable file.

When the macros gets expanded? at the time of pre processing

Write a c program to print Hello world without using any semicolon?
	void main()
	{
		if(printf("Hello world")){}
    }
	
Do you know pragma directives in c? it is a compiler-specific preprocessor extension. Have not worked on it at all.
	To call a function before main(), pragma startup directive should be used,
		#pragma startup fun
		void fun()
		{
		 printf(“In fun\n”);
		}
		main()
		{
		 printf(“In main\n”);
		}
	
	o/p:
		In fun
		In main

	NOTE: But this pragma directive is compiler dependent. Gcc does not support this. So, it will ignore the startup directive and will produce no error. 	
		  But the output in that case will be - "In main"

		
What is array of pointers in c? it is array of pointers, i.e. the array comprises of address
	example,
		int arr[3] = {1,2,3};
		int *ptr[3] = {arr, arr+1,arr+2};
		printf("%u,%d", ptr, *ptr, *(*ptr));
		
Can you declare such function which return type is pointer to an enum?
example,
		#include <stdio.h>
		typedef enum color{a,b,c,d,e}co;
		enum color eee(){
			static co x;
			x=b+c/2;
			return x;
		}
		int main(){
			int num;
			num=eee();
			printf("%#d",num);
			return 0;
		}
		
	o/p: 2
 
Can you declare pointer to structure in c?
 
What is pointer to array of character in c?
		#include<stdio.h>
		char display(char (*)[]);
		int main(){
			char c;
			char character[]={65,66,67,68};  //{A,B,C,D}
			char (*ptr)[]=&character; /*ptr has address of char array*/
			c=display(ptr);
			printf("%c",c);
			return 0;
		}
		char display(char (*s)[]){
			**s+=2;   *(*s) = *(*&character) = *(65)
			return **s;
		}

		Output: C

		Explanation: Here function display is passing pointer to array of characters and returning char data type.
		**s+=2
		=>**s=**s+2
		=>**ptr=**ptr+2 //s=ptr
		=>**&character= **&character+2 //ptr=&character
		=>*character=*character+2 //from rule *&p =p
		=>character[0]=character[0]+2 //from rule *(p+i)=p[i]
		=>character [0] =67
		**s=character [0] =67

		Note: ASCII value of ‘C’ is 67 
	

Can you explain pointer to two dimensional arrays in c by an example?
		int main
		{
			int s[5][2] = {
							{1234,56},
							{1212,34},
							{1434,80},
							{1312,78}
						};
						
			int (*p)[2];
			int i,j,*pint;
			
			for(i=0;i<=3;i++)
			{
				p = &s[i];
				pint = p;
				printf("\n");
				for (j=0;j<=1;j++)
				{
					printf("%d",*(pint + j);
				}
			}
		}
		
What is data segment in c?
Local Variables			//stored in a memory area called Stack.
Free Memory				//heap space between stack and permanent storage. This is used for dynamic memory allocation during execution of the program. 
global Variable			//get their memory in permanent storage. 
Program Instructions	//get their memory in permanent storage.
static Variable         //get their memory in permanent storage.

http://www.cquestions.com/2011/12/advanced-c-interview-questions-and.html

What is the difference between declaration and definition of a variable/function?
	// This is only declaration. y is not allocated memory by this statement 
	extern int y; 

	// This is both declaration and definition, memory to x is allocated by this statement.
	int x;
	

What is memory leak? Why it should be avoided?
	Memory leak occurs when programmers create a memory in heap and forget to delete it. Memory leaks are particularly serious issues for programs like 
	daemons and servers which by definition never terminate.
	
	/* Function with memory leak */
	#include <stdlib.h>
	void f()
	{
	   int *ptr = (int *) malloc(sizeof(int));
	   /* Do some work */
	   return; /* Return without freeing ptr*/
	}
	
What is difference between i++ and ++i?
	 1) The expression ‘i++’ returns the old value and then increments i. The expression ++i increments the value and returns new value.
	 2) Precedence of postfix ++ is higher than that of prefix ++.
	 3) Associativity of postfix ++ is left to right and associativity of prefix ++ is right to left.
	 
Predict the output of following C programs?
	// PROGRAM 1
	#include <stdio.h>
	int main(void)
	{
		int arr[] = {10, 20};
		int *p = arr;
		++*p;
		printf("arr[0] = %d, arr[1] = %d, *p = %d", arr[0], arr[1], *p);
		return 0;
	} 
	
	o/p: arr[0] = 11, arr[1] = 20, *p = 11
	
	// PROGRAM 2
	#include <stdio.h>
	int main(void)
	{
		int arr[] = {10, 20};
		int *p = arr;
		*p++;
		printf("arr[0] = %d, arr[1] = %d, *p = %d", arr[0], arr[1], *p);
		return 0;
	}
	
	o/p: arr[0] = 10, arr[1] = 20, *p = 20
	
	NOTE:
	The output of above programs and all such programs can be easily guessed by remembering following simple rules about postfix ++, prefix ++ and * 
	(dereference) operators
	1) Precedence of prefix ++ and * is same. Associativity of both is right to left.
	2) Precedence of postfix ++ is higher than both * and prefix ++. Associativity of postfix ++ is left to right.

How will you print numbers from 1 to 100 without using loop?
		We can use recursion for this purpose. 
		/* Prints numbers from 1 to n */
		void printNos(unsigned int n)
		{
		  if(n > 0)
		  {
			printNos(n-1);
			printf("%d ",  n);
		  } 
		}
		
What is volatile keyword? C's volatile keyword is a qualifier that is applied to a variable when it is declared. It tells the compiler that the value of the variable may change at any time--without any action being taken by the code the compiler finds nearby. 
To declare a variable volatile, include the keyword volatile before or after the data type in the variable definition.
example,
	volatile int foo; 
	int volatile foo;

Describe the modifier in C?
	Modifier is a prefix to the basic data type which is used to indicate the modification for storage space allocation to a variable.
	In 32-bit processor storage space for int data type is 4.When we use it with modifier the storage space change as follows.
		•Long int -> Storage space is 8 bit
		•Short int -> Storage space is 2 bit
	There are 5 modifiers available,
	Short
	Long
	Signed
	Unsigned
	long long
	
What is the process to generate random numbers in C programming language?
 The command rand() is available to use for this purpose. The function returns any integer number beginning from zero(0). 
 
	 int main()
	 {
		int a,b;
		for (a=1;a<11;a++)
		{
			b = rand();
			/*print b*/
		}
		return 0;
	 }
	 
Is there any possibility to create customized header file with C programming language?
	It is possible and easy to create a new header file. Create a file with function prototypes that needs to use inside the program. Include the file in 
	‘#include’ section from its name.

What will be the output of printf(“%d”)? garbage value. The first argument which contains strings to be printed or format specifiers is mandatory. Other than that, the arguments are optional.

What is the return values of printf?  The printf function upon successful return, returns the number of characters printed in output device. So, printf(“A”) will return 1

How to free a block of memory previously allocated without using free? If the pointer holding that memory address is passed to realloc with size argument as zero (like realloc(ptr, 0)) the the memory will be released.

How can you print a string containing '%' in printf? To print '%' one should use '%%'

What is use of %n in printf()? it will get the number of characters already written until %n is encountered and this number will stored in the variable provided.
example,
		#include<stdio.h>
		main()
		{
		 int c;
		printf("Hello%n world ",&c);
		 printf("%d", c);
		}
 
	o/p Hello 5 World.

How to convert a string to integer value? int i = atoi(str);

How to prevent same header file getting included multiple times? We can use ifndef and define preprocessors. Say the header file is hdrfile.h, then we can write the header file like -
#ifndef _HDRFILE_H_
#define _HDRFILE_H_
#endif
The ifndef will check whether macro HDRFILE_H_ is defined or not. If it is not defined, it will define the macro. From next time onward the statements inside ifndef will not be included.

 This preprocessor determines if the provided macro does not exist before including the subsequent code in the compilation process.
example,
		#include <stdio.h>
		#define YEARS_OLD 12
		#ifndef YEARS_OLD
		#define YEARS_OLD 10
		#endif
		int main()
		{
		   printf("TechOnTheNet is over %d years old.\n", YEARS_OLD);

		   return 0;
		}
		
	o/p:
	TechOnTheNet is over 12 years old.
	"If you remove the line #define YEARS_OLD 12, you will see the following output from the executable program:
		TechOnTheNet is over 10 years old."
