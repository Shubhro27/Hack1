https://career.guru99.com/top-50-oracle-interview-questions-and-answers/
https://www.besanttechnologies.com/oracle-interview-questions-and-answers
https://mindmajix.com/sql-interview-questions

https://intellipaat.com/interview-question/sql-interview-questions/
http://www.testingbrain.com/interview/oracle-interview-questions.html
https://mindmajix.com/oracle-pl-sql-interview-questions
#########################################################################################
SQL: Structured Query Language is non-procedural language used for data retrieval, data update, insert or delete data from an database.

different Oracle Database objects:
Tables – set of elements organized in vertical and horizontal
Views  – Virtual table derived from one or more tables
Indexes – Performance tuning method for processing the records
Synonyms – Alias name for tables
Sequences – Multiple users generate unique numbers
Tablespaces – Logical storage unit in Oracle

types of SQL statements:
Data Retrieval: SELECT
Data Manipulation Language (DML): INSERT, UPDATE, DELETE, MERGE
Data Definition Language (DDL): CREATE, ALTER, DROP, RENAME, TRUNCATE.
Transaction Control Statements: COMMIT, ROLLBACK, SAVEPOINT
Data Control Language (DCL): GRANT, REVOKE

What is DUAL?
The DUAL table is owned by the user SYS and can be accessed by users. 
It contains one column, DUMMY, and one row with the value X. 
The DUAL table is useful when you want to return a value once only.
for instance, the value of a constant, pseudocolumn, or expression that is not derived from a table with user data. 

maximum no.of columns a table can have ?
254.

Comments in Oracle:
-- for single line
/*.....*/ for multi line

order of Precedence used in executing SQL statements:
Arithmetic operators -> concatenation operators (||) -> comparision condition -> logical condition 

SELECT DISTINCT(colname) from table_name to get DISTINCT values in the column.

Data Manipulation Language (DML) is used to access and manipulate data in the existing objects. insert, select, update and delete.

NULL value in oracle: is just a place holder for missing/unknown data.

Describe <Table_Name> is used to get the field details.

difference between $ORACLE_BASE and $ORACLE_HOME?
Oracle base is the main or root directory of an oracle whereas ORACLE_HOME is located beneath base folder in which all oracle products reside.

fastest query method to fetch data from the table?
Using ROW ID is the fastest query method to fetch data from the table.

display row numbers with the records? select rownum, <fieldnames> from table;

How can we view last record added to a table? Select * from (select * from employees order by rownum desc) where rownum<2;


How to display employee records who gets more salary than the average salary in the department? 
Select * from employee where salary > (select avg(salary) from dept, employee where dept.deptno = employee.deptno);

Oracle literals are strings (can have character, a number, or a date) which can included in SELECT statement along with column name
ex, Select last_name||’is a’||job_id As “emp details” from employee; (Here “is a” is a literal).

How to save the query output with spool on a text file?
SPOOL 'D:\sqltestes\sql_test.txt'
SELECT max(column1) from my_table;
SPOOL OFF;
//and hit F5


to determine leap year:
create or replace function IS_LEAP_YEAR (nYr in number) return boolean is 
v_day varchar2(2); 
begin 
  select to_char(last_day(to_date( '01-FEB-'|| to_char(nYr), 'DD-MON-YYYY')), 'DD') into v_day from dual; 
  if v_day = '29' then -- if v_day = 29 then it must be a leap year, return TRUE 
    return TRUE; 
  else 
    return FALSE;  -- otherwise year is not a leap year, return false 
  end if; 
end;

select second max salary from a table:
select * from sivaemp where salary = 
(select max(salary) from emp where salary not in (select max(salary) from emp))


Top N maximum and min salaries from a table:
select * from sivaemp a where &n > (select count(*) from sivaemp b where a.salary < b .salary)   /*for max*/
select * from sivaemp a where &n > (select count(*) from sivaemp b where a.salary > b.salary)    /*for min*/


Create a copy of EMP table without any data:
CREATE TABLE EMP1 SELECT * FROM EMP WHERE 'X' = 'Y';

Delete 10th record of EMP table:
DELETE FROM EMP WHERE ENAME = (SELECT ENAME FROM EMP WHERE ROWNUM < =10 MINUS SELECT ENAME FROM EMP WHERE ROWNUM<10);

find departments where employee count is > 3:
SELECT D.DNAME, COUNT (E.ENAME) FROM EMP E, DEPT D WHERE D.DEPTNO=E.DEPTNO GROUP BY DNAME HAVING COUNT (EMPNO) > 3;

Display the name of employees who joined on the same date:
SELECT A.ENAME FROM EMP A, EMP B WHERE A.EMPNO < > B.EMPNO AND A.HIREDATE=B.HIREDATE;

Delete those employees who joined the company 10 years back from today?
SELECT ENAME FROM EMP WHERE (SYSDATE-HIREDATE)/365 > 10

Display those employees whose salary is ODD value?
SELECT ENAME, SAL FROM EMP WHERE MOD (SAL, 2) < > 0;

What is Oracle Transaction? Describe common errors can occur while executing any Transaction
Set of SQL statements between 2 commits or rollbacks.
The violation of constraints.
Data type mismatch.
Value too wide to fit in column.
The system crashes or Server gets down.
The session Killed.
Locking take place. Etc.

Which of the following is not a schema object : Indexes, tables, public synonyms, triggers and packages ?
Public synonyms

Locking in SQL:
Locking prevents destructive interaction between concurrent transactions. Locks (both implicit and explicit) held until Commit or Rollback
Types of locking are: 
Implicit Locking: Occurs for all SQL statements except SELECT.
Explicit Locking: Can be done by user manually.To explicitly LOCK -- select .... where ... FOR UPDATE; 
example,
	SQL> select * from emp where empno in (7369, 7521, 7698) for update ;

	EMPNO ENAME      JOB         MGR HIREDATE          SAL      COMM DEPTNO
	----- ---------- --------- ----- ----------- --------- --------- ------
	 7369 SMITH      CLERK      7902 17-Dec-1980    800.00               20
	 7521 WARD       SALESMAN   7698 22-Feb-1981   1250.00    500.00     30
	 7698 BLAKE      MANAGER    7839 01-May-1981   2850.00               30
	 
	 
Find What is Wrong in this Query?
SELECT subject_code, AVG (marks) FROM students WHERE AVG(marks) > 75 GROUP BY subject_code; 
The WHERE clause cannot be used to restrict groups. Instead, the HAVING clause should be used.
	SELECT subject_code, AVG (marks)
	FROM students
	HAVING AVG(marks) > 75
	GROUP BY subject_code;

##################################################################################
varchar and varchar2?
varchar							varchar2
can store up to 2000 bytes		can store up to 4000 bytes
occupies SPACE for NULL			can accomodate NULL

Char can store up to 255 bytes.

As of now both are used as synonyms regarding memory allocation & release. both r variable in length and occupies memory at runtime.
In future, VARCHAR2, is supposed to, not distinguish between a NULL and empty string while VARCHAR will do,

SELECT 
    '"'||CAST('abc' AS VARCHAR2(10))||'"', 
	'"'||CAST('abc' AS VARCHAR(10))||'"', 
    '"'||CAST('abc' AS CHAR(10))||'"' 
FROM dual;

'"'||CAST('ABC'ASVARCHAR2(10))||'"' '"'||CAST('ABC'ASVARCHAR(10))||'"' '"'||CAST('ABC'ASCHAR(10))||'"'
----------------------------------- -------------------------------    ------------------------------- 
"abc"                               "abc" 							    "abc       "                   
1 row selected.

In case of a fixed length column (like postal code, SSN), har avoids the need to code an rpad() expression. 
If you rely on empty string and NULL being the same thing, you should use VARCHAR2.

##############################################################################
RAW datatype? 
used to store values in variable length binary data format OR byte string. 
Maximum size for:
PL/SQL declaration is 32767 bytes. 
database columns is 255 bytes.

syntax can be: VARIABLE RAW(precision)
example,
	CREATE TABLE T_RAW (HEX_CODE RAW(3));   	    // Here 16 implies 16 bytes. So if we try to insert data > 16 bytes, it will fail with "value error"
	INSERT INTO T_RAW VALUES (HEXTORAW('414141'));  // Success
	INSERT INTO T_RAW VALUES (HEXTORAW('414141F')); // will fail with "value error"
	SELECT (RAWTOHEX(T_RAW)) FROM T_RAW;     

##############################################################################
Date / Time Arithmetic with Oracle?

Date Data Types:
1) Date: is used to store month, day, year, century, hours, minutes, and seconds. However, does not support doing arithmetic on the column.
   example,
   CREATE TABLE t(dob DATE);
   INSERT INTO t(dob) VALUES(TO_DATE('17/12/2015', 'DD/MM/YYYY'));
   SELECT dob,to_char(dob,'MMDDYYYY:HH24:MI:SS')dob1 FROM t;

2) Timestamp: this is extension of Date and adds fractional seconds to the current date time format. TRUNC function will not work with a datatype of TIMESTAMP.
              TIMESTAMP datatype should explicitly be used for date and times where a difference in time is of utmost importance.   
			a) convert date field to timestamp.
               SELECT CAST(date1 AS TIMESTAMP) "Date" FROM t;
               O/p: (NOTE: there is a 000000 field due to empty time on original date field)
				Date
				-----------------------------------------------------
				20-JUN-03 04.55.14.000000 PM			   
   
            b) Inserting TIMESTAMP value into table
				1) insert into tablename (timestamp_value) values (TO_TIMESTAMP(:ts_val, 'YYYY-MM-DD HH24:MI:SS'));
				2) CURRENT_TIMESTAMP, SYSTIMESTAMP, sysdate are Oracle reserved words
				   INSERT INTO mytable (timestamp_field) VALUES(CURRENT_TIMESTAMP)
				3) insert into the_table(the_timestamp_column) values (timestamp '2017-10-12 21:22:23');
				
	With timestamp, we can do time arithmetic,
	SELECT time1,  time2,  (time2-time1) from date_table
	
Date time functions include:
ADD_MONTHS: Adds the specified number of months to a date. 
LAST_DAY: Returns the last day in the month of the specified date. 
MONTHS_ BETWEEN: Calculates the number of months between two dates. 
NEW_TIME: Returns the date/time value, with the time shifted as requested by the specified time zones.  
NEXT_DAY: Returns the date of the first weekday specified that is later than the date.  
ROUND: Returns the date rounded by the specified format unit. 
SYSDATE: Returns the current date and time in the Oracle Server. 
TRUNC: Truncates the specified date of its time portion according to the format unit provided.  

You can refer: http://www.baskent.edu.tr/~tkaracay/etudio/ders/dbase/sql/pdfSQL/DateFunctions.pdf
               https://www.databasejournal.com/features/oracle/article.php/2234501/A-Comparison-of-Oracles-DATE-and-TIMESTAMP-Datatypes.htm
			   
date and time data types are also called temporal datatypes. So we have 3 in oracle,
Date
TimeStamp
Interval: are used to store periods of time. There are 2 types,
	INTERVAL YEAR TO MONTH – stores intervals using of year and month.
	INTERVAL DAY TO SECOND – stores intervals using days, hours, minutes, and seconds including fractional seconds.
###########################################################
 
Nested Table:
is a table which supports columns containing multivalued attributes (i.e. table containing subtables)
It is similar to VARRAY 
Elements can be deleted or added anywhere in the nested table where as a VARRAY can only add or delete elements from the end of the array.

NOTE: for details on VARRAY, refer to http://www.orafaq.com/wiki/VARRAY.	

example-1,
1) CREATE OR REPLACE TYPE my_tab_t AS TABLE OF VARCHAR2(30);
2) CREATE TABLE nested_table (id NUMBER, col1 my_tab_t) NESTED TABLE col1 STORE AS col1_tab;
3) Insert data as,
	 INSERT INTO nested_table VALUES (1, my_tab_t('A'));
	 INSERT INTO nested_table VALUES (2, my_tab_t('B', 'C'));
	 INSERT INTO nested_table VALUES (3, my_tab_t('D', 'E', 'F'));
	 COMMIT;
	 
4) SELECT * FROM nested_table;
			ID COL1
	---------- ------------------------
			 1 MY_TAB_T('A')
			 2 MY_TAB_T('B', 'C')
			 3 MY_TAB_T('D', 'E', 'F')
			 
5) SELECT id, COLUMN_VALUE FROM nested_table t1, TABLE(t1.col1) t2;
			ID COLUMN_VALUE
	---------- ------------------------
			 1 A
			 2 B
			 2 C
			 3 D
			 3 E
			 3 F
			 
example-2,
1) 
	CREATE TYPE address_t AS OBJECT (
	   street  VARCHAR2(30),
	   city    VARCHAR2(20),
	   state   CHAR(2),
	   zip     CHAR(5) );
   
2) CREATE TYPE address_tab IS TABLE OF address_t;

3) 
	CREATE TABLE customers (
	   custid  NUMBER,
	   address address_tab )
	NESTED TABLE address STORE AS customer_addresses;

4) 
	INSERT INTO customers VALUES (1,
				address_tab(
				  address_t('101 First', 'Redwood Shores', 'CA', '94065'),
				  address_t('123 Maple', 'Mill Valley',    'CA', '90952')
				)                );
  
5)	select c.custid, u.* from customers c, table (c.address) u;
  
#############################################################################
COALESCE function:
COALESCE function returns the first non-null expression in the list. The COALESCE function will compare each value in the list, one by one.
Syntax is: COALESCE( expr1, expr2, ... expr_n ) where,
			The expressions to test for non-null values. The expressions must all be the same datatype.
			
example,
SELECT COALESCE( address1, address2, address3 ) result FROM suppliers;

is equivalent to,
IF address1 is not null THEN
   result := address1;
ELSIF address2 is not null THEN
   result := address2;
ELSIF address3 is not null THEN
   result := address3;
ELSE
   result := null;
END IF;

In case of 2 arguments of same type COALESCE behaves similar to NVL.
example,
SELECT nvl(:column_name,'10') FROM table_name;
SELECT coalesce(:column_name,'10') FROM table_name;

However, they are implemented differently:
NVL always evaluates both arguments
COALESCE doesn't evaluate anything after it finds the first non-NULL argument

###################################################################################
BLOB datatype:
Varying length binary string which is used to store two gigabytes memory. Length should be specified in Bytes for BLOB
Blobs (binary large objects) are typically images, audio, video or other multimedia objects, though sometimes binary executable code is stored as a blob. 
These datatypes came into existance when storage became cheap.
 
We can store pictures in the database by Long Raw Data type. 
This datatype is used to store binary data for 2 gigabytes of length. But the table can have only on Long Raw data type.
###################################################################################
difference between TRANSLATE and REPLACE?

Translate is used for character by character substitution
Replace is used substitute a single character with a word.

TRANSLATE(STRING,IF,THEN):  looks at each character in 'STRING' and then check 'IF' to see if that character is there, 
							if it is there then it notes the position in 'IF' where it found the character and then looks the same position in 'THEN'.
							
example,
SELECT TRANSLATE('NOW VOWELS ARE UNDER ATTACK','TAEIOU','Taeiou') FROM dual;
O/p:
Result- NoW VoWeLS aRe uNDeR aTTaCK

SELECT TRANSLATE(7671234,234567890,'BCDEFGHIJ') FROM dual;
O/p:
Result of the query above is- GFG1BCD


SELECT REPLACE('ADAH','A','BLAH') FROM dual;
O/p:
Result: BLAHDBLAHH

SELECT REPLACE('GEORGE','GE',NULL) FROM DUAL;
O/p:
Result: OR

##################################################################################
Merge statement:
Selects data from one or more source tables and updates or inserts it into a target table. 
Merge allows you to specify a condition to determine whether to update data from or insert data into the target table.
You can add an optional DELETE WHERE clause to the MATCHED clause to clean up after a merge operation. However,
you cannot delete rows that have not been updated by the merge command.


syntax is:
MERGE INTO target_table 
USING source_table 
ON search_condition
    WHEN MATCHED THEN
        UPDATE SET col1 = value1, col2 = value2,...
        WHERE <update_condition>
        [DELETE WHERE <delete_condition>]
    WHEN NOT MATCHED THEN
        INSERT (col1,col2,...)
        values(value1,value2,...)
        WHERE <insert_condition>;
		
example,
	create table catalog1 (id number(3), item varchar2 (20), price number(6))
	 
	insert into catalog1 values(1, 'laptop', 800)
	insert into catalog1 values(2, 'iphone', 500)
	insert into catalog1 values(3, 'camera', 700)

	select * from catalog1

	O/p:
	ID	ITEM	PRICE
	1	laptop	800
	2	iphone	500
	3	camera	700

	create table catalog2 (id number(3), item varchar2 (20), price number(6))
	insert into catalog2 values(1, 'laptop', 899)
	insert into catalog2 values(2, 'iphone', 599)
	insert into catalog2 values(5, 'video camera', 799)

	select * from catalog2

	O/p:
	ID	ITEM			PRICE
	1	laptop			899
	2	iphone			599
	5	video camera	799

	MERGE INTO catalog1 s1 USING catalog2 s2 ON (s1.id = s2.id) 
	WHEN MATCHED THEN UPDATE SET s1.price = s2.price  
	WHEN NOT MATCHED THEN INSERT (id, item, price) values (s2.id, s2.item, s2.price)

	O/p:
	ID	ITEM			PRICE
	1	laptop			899
	2	iphone			599
	3	camera			700
	5	video camera	799
	
example-2,
	MERGE INTO member_staging x
	USING (SELECT member_id, first_name, last_name, rank FROM members) y
	ON (x.member_id  = y.member_id)
	WHEN MATCHED THEN
		UPDATE SET x.first_name = y.first_name, 
							x.last_name = y.last_name, 
							x.rank = y.rank
		WHERE x.first_name <> y.first_name OR 
			   x.last_name <> y.last_name OR 
			   x.rank <> y.rank 
	WHEN NOT MATCHED THEN
		INSERT(x.member_id, x.first_name, x.last_name, x.rank)  
		VALUES(y.member_id, y.first_name, y.last_name, y.rank);
		
example-3, (with delete)
when matched then update set dummy=dummy
    where a_value not in ('ace','afk')
delete 
    where a_value not in ('ace','afk')
	
##############################################################################################
JOINS

cross join: "Cartesian product of records from the tables present in the join"
i.e. Cross join will produce result which combines each row from the first table with the each row from the second table. 
example,
	SELECT first_name, department_name FROM employees CROSS JOIN departments;
	SELECT * FROM regions CROSS JOIN countries WHERE country_id='AU';
	SELECT * FROM customer,supplier  
refer: https://www.w3resource.com/sql/joins/cross-join.php for complete example

where can cross join be used?
cross join is used to "show all possible combinations"
For example, say you are building an arbitrage (trading) application. 
You have sellers offering products at a price and buyers asking for products at a cost. 
You do a cross join on the product key (to match up the potential buyers and sellers), calculate the spread between cost and price, 
then sort desc. on this to give you (the middleman) the most profitable trades to execute.

##############################################################################################
Key preserved table (obtained in joins):
Students table(studentid,name,courseid) has a primary key on student ID (i.e. no duplicate values of studentid)
(1,A,1A)
(2,B,1A)
(3,C,1B)
(4,D,1A)

Course table(courseid,coursename) has a primary key on course ID.
(1A,10g)
(1B,11g)

so, when joined on courseid as, select * from t_students S, t_course C where S.courseid=C.courseid; 
O/p:
(1,A,1A,10g)
(2,B,1A,10g)
(3,C,1B,11g)
(4,D,1A,10g)

Conclusion,
1) studentid is preserved   : The resulting data will have exactly the same number of rows as the Students table.
   As There will be no duplicate values of studentid in the result set. 
2) courseid is not preserved: Though the courseid is unique in course table, it will be repeated multiple times in the result set, 
   as many students may have opted for the same course.

With this example in place, you can come to a conclusion that:
Every Key in the base table acts as the key to the resultant data after join(studentid)
The rows from the base row appear in the resultant data AT MOST ONLY ONCE.(No duplicate rows)

This is the concept of Key Preserved Tables.

################################################################################################
Views:
is a virtual table created from querying a single table or query joining multiple tables.

Create View: 
	SYNTAX is:
	CREATE VIEW view_name AS
	SELECT columns
	FROM tables
	[WHERE conditions];

	example,
	CREATE VIEW sup_orders AS
	SELECT suppliers.supplier_id, orders.quantity, orders.price
	FROM suppliers
	INNER JOIN orders
	ON suppliers.supplier_id = orders.supplier_id
	WHERE suppliers.supplier_name = 'Microsoft';
	
Update View: 
	SYNTAX is:
	CREATE OR REPLACE VIEW view_name AS
	SELECT columns
	FROM table
	WHERE conditions;

	example,
	CREATE or REPLACE VIEW sup_orders AS
	SELECT suppliers.supplier_id, orders.quantity, orders.price
	FROM suppliers
	INNER JOIN orders
	ON suppliers.supplier_id = orders.supplier_id
	WHERE suppliers.supplier_name = 'Apple';
  
Delete/Drop view:
	SYNTAX is: DROP VIEW view_name;
    example, DROP VIEW sup_orders;
	
NOTE:
When you update record(s) in a VIEW, it updates the records in the underlying tables that make up the View. (unless the view is marked as READ-ONLY)
in Oracle, the VIEW continues to exist even after one of the tables is fropped from view but querying such views errors.
If you recreate the table (the table that you had dropped), the Oracle VIEW will again be fine.

WITH CHECK OPTION:
views can be created with “WITH CHECK OPTION”  and “WITH READ ONLY“.

Both options are used to restrict Insert and Update performed through the view.

Differences between the 2 include:
If view is created with “WITH READ ONLY” no data manipulation is allowed in any condition. Only selects are allowed against the views.
If view is created with “WITH CHECK OPTION” row insertion is allowed but restricted. It makes sure, no rows are updated which do not appear in the view.

NOTE: “WITH CHECK OPTION” works for update, and insert. It does not allow delete even if the delete satisfies the condition.

example-1,
1) CREATE TABLE:
	create table jbt_employee(name varchar2(20), address varchar2(20), phone number);

2) CREATE VIEWS:
	"With Read Only"
		CREATE OR REPLACE FORCE VIEW jbt_read_only_view AS SELECT * FROM jbt_employee    
		WHERE phone < 8          
		WITH READ ONLY CONSTRAINT read_only_const_name

	“WITH CHECK ONLY”
		CREATE OR REPLACE FORCE VIEW jbt_check_option_view AS SELECT * FROM jbt_employee    
		WHERE phone < 8          
		WITH CHECK OPTION CONSTRAINT check_option_const_name
		
3) Try to insert rows into views:
	a) insert into jbt_read_only_view values('name', 'address', 9);
		Error Thrown : ORA-01733: virtual column not allowed here
		
	b) insert into jbt_check_option_view values('name', 'address', 7);
		Successfully Fired.
		
	c) insert into jbt_check_option_view values('name', 'address', 9);
		Error Thrown : ORA-01402: view WITH CHECK OPTION where-clause violation
	
example-2,
create table Customers (
id  int not null,
customer_name   varchar(100) not null,
county varchar(50) not null,
status char(1) not null
)

insert Customers ( customer_name, county ) values( 'Trevor Dwyer', 'Hertfordshire' )
insert Customers ( customer_name, county ) values( 'Tony Rogerson', 'Hertfordshire' )
insert Customers ( customer_name, county ) values( 'Simon Sabin', 'Hertfordshire' )
insert Customers ( customer_name, county ) values( 'Mark Allison', 'Bedfordshire' )
insert Customers ( customer_name, county ) values( 'Peter Blackburn', 'Cambridgeshire' )

create view vw_Customers_Hertfordshire
as select id, customer_name, status, County from Customers where county = 'Hertfordshire' with check option;

These calls will error:
1) update vw_Customers_Hertfordshire set status = 'M';
2) update vw_Customers_Hertfordshire set county = 'Cumbria';

These calls will be successful:
1) update Customers set county = 'Cumbria' where county = 'Hertfordshire';
2) update Customers set status = 'M' where county = 'Hertfordshire';

################################################################################################
Oracle Snapshots:

It is a read only copy of the master table on a remote node which is refreshed periodically to reflect changes in the master table.

we can create a snapshot as,
CREATE SNAPSHOT AS SELECT * FROM <TABLE-NAME>;

CREATE SNAPSHOT AS SELECT COL1,COL2..... FROM <TABLE-NAME> WHERE......;

Snapshot and materialized view are almost same same but with one difference.

You can say that, materialized view =snapshot + query rewrite functionality

query rewrite functionality:In materialized view you can enable or disable query rewrite option. 
which means databse server  will rewrite the query so as to give high performance. 
Query rewrite is based on some prewritten standards(by oracle itself).
So the database server will follow these standards and rewrite the query written in the materilized view..

but this functionality is not there in snapshots

################################################################################################
ORACLE Subqueries:
a query which is added to the where clause of another query becomes a sub-query.
2 types of subqueries:
1) correlated subqueries: dependent query i.e. the outer query depends on the subquery.
	a) example-1,(subquery in the WHERE clause example)
		SELECT product_id, product_name, list_price
		FROM
			products
		WHERE
			list_price =(
				SELECT
					MIN( list_price )
				FROM
					products
			);
			
	b) example-2,(subquery in the SELECT clause example)
		SELECT
			product_id,
			product_name,
			standard_cost,
			ROUND(
				(
					SELECT AVG( standard_cost ) FROM products
					WHERE category_id = p.category_id
				),
				2
			) avg_standard_cost
		FROM
			products p
		ORDER BY
			product_name;

	c) example-3 (Oracle correlated subquery with the EXISTS operator example)
		SELECT customer_id, name
		FROM
			customers
		WHERE
			NOT EXISTS (
				SELECT * FROM orders
				WHERE
				orders.customer_id = customers.customer_id
			)
		ORDER BY
		name;	
		
		SELECT *
		FROM customers
		WHERE EXISTS (SELECT * FROM order_details
					  WHERE customers.customer_id = order_details.customer_id);
					  
	d) example-4 (inline queries, i.e. subquery in FROM clause)
		SELECT suppliers.name, subquery1.total_amt
		FROM suppliers,
		 (SELECT supplier_id, SUM(orders.amount) AS total_amt
		  FROM orders
		  GROUP BY supplier_id) subquery1
		WHERE subquery1.supplier_id = suppliers.supplier_id;

2) non-correlated subqueries: There is no reference of outer query table fields in the subquery. 
	example-1,
	select * from departments where employee_id in (select employee_id from employees);
	i.e. there is no reference to departments in the subquery. 
	
	example-2
	SELECT * 
	FROM all_tables tabs
	WHERE tabs.table_name IN (SELECT cols.table_name
							  FROM all_tab_columns cols
							  WHERE cols.column_name = 'SUPPLIER_ID');
							  
------
sub queries can also be typed as,
Single-Row Sub query: Queries that return only one row from the Inner select statement. 
                      Single-row comparison operators are: =, >, >=, <, <=, <>

Multiple-Row Sub query: Queries that return more than one row from the inner Select statement. 
                        There are also multiple-column sub queries that return more than one column from the inner select statement. 
						Operators includes: IN, ANY, ALL.
	
------
ANY vs ALL:

1) ANY: performs an OR operation on each value in the list. Must be preceded by =,!=,>,<,<=,=>.
		example,
		select empno,ename,sal from emp where sal = any(1500,3000);
		here optimizer take above query as --select empno,ename,sal from emp where sal>1500 or sal>3000;
		
2) ALL: performs an AND operation on each value in the list. Must be preceded by =,!=,>,<,=>,<=
		example,
		select empno,ename,sal from emp where sal > ALL (1600,3000);
		here optimizer take this query as --select empno,ename,sal from emp where sal 1600 AND sal>3000;
		
		
################################################################################
Oracle Schemas:
A schema allows you to logically group objects in an Oracle database.

In order to create a schema,
1) create a user
	CREATE USER smithj
	  IDENTIFIED BY pwd4smithj

2) Assign SYSTEM privileges to new user
	GRANT create session TO smithj;
	GRANT create table TO smithj;
	GRANT create view TO smithj;
	GRANT create any trigger TO smithj;
	GRANT create any procedure TO smithj;
	GRANT create sequence TO smithj;
	GRANT create synonym TO smithj;
	
3) create objects in the schema like tables, views

4) grant object privileges
	example, GRANT SELECT, INSERT, UPDATE, DELETE ON suppliers TO smithj;
	GRANT ALL ON suppliers TO smithj;   -- ALL permissions to be granted for a user named smithj.
	GRANT SELECT ON suppliers TO public; --to grant only SELECT access on your table to all users, you could grant the privileges to the public keyword.
	
To revoke privelages:
Syntax: REVOKE privileges ON object FROM user;
example,
	REVOKE DELETE ON suppliers FROM anderson;
	REVOKE ALL ON suppliers FROM anderson;
	REVOKE ALL ON suppliers FROM public;

-- Grant/Revoke privileges on functions/procedures
Syntax is: 
for GRANT  : GRANT EXECUTE ON object TO user;
for REVOKE : REVOKE EXECUTE ON object FROM user;
example,
GRANT EXECUTE ON Find_Value TO public;
GRANT EXECUTE ON Find_Value TO smithj;

REVOKE execute ON Find_Value FROM anderson;
REVOKE EXECUTE ON Find_Value FROM public;

What are privileges and Grants?
Privileges are the rights to execute SQL statements
Grants are given to the object so that objects can be accessed accordingly.

#####################################################################################
rename and alias:

Rename is a permanent name given to a table or a column 
whereas 
Alias is a temporary name given to a table or column. Alias acts as an alternate name of the table or column.

1) Rename Table or View
	ALTER TABLE mytable RENAME TO othertable
	OR
	RENAME mytable TO othertable   -- both options supports renaming a table in same schema
	
	ALTER TABLE owner.mytable RENAME TO othertable;  --rename a table in a different schema
	
	RENAME view_name TO new_view_name; --for views
	
2) Rename indexes:
	alter index owner.index_name rename to new_name;
	
3) Rename column:
	ALTER TABLE employee RENAME COLUMN f_name TO first_name;
	

--Alias
1) column alias: i.e. column_name AS alias_name
	example-1, (aliased the second column (ie: first_name and last_name concatenated) as NAME)
		SELECT contact_id, first_name || last_name AS NAME FROM contacts WHERE last_name = 'Anderson';

	example-2, (spaces in the alias name can be put in " ")
		SELECT contact_id, first_name || last_name AS "CONTACT NAME" FROM contacts WHERE last_name = 'Anderson';
		
2) table alias: i.e. table_name alias_name
	example-1
		SELECT p.product_id, p.product_name, categories.category_name
		FROM products p
		INNER JOIN categories
		ON p.category_id = categories.category_id
		ORDER BY p.product_name ASC, categories.category_name ASC;
		
	example-2
		SELECT p.product_id, p.product_name, c.category_name
		FROM products p
		INNER JOIN categories c
		ON p.category_id = c.category_id
		ORDER BY p.product_name ASC, c.category_name ASC;
		
#########################################################################################
Cursors:
It is a reference variable.
It is a facility provided by oracle to assign a name to SELECT statement and manipulate the info retrieved from the SELECT Statement.

Why is cursor used? it is used to process each row when a query returns multiple rows.

1) declare a cursor: CURSOR <name> (optional parameter-list) is SELECT_STATEMENT
	example-1, (cursor without parameters)
		CURSOR c1
		IS
		SELECT course_number FROM courses_tbl WHERE course_name = name_in;
	
	example-2, (cursor with parameters)
		CURSOR c2 (subject_id_in IN varchar2)
		IS
		SELECT course_number FROM courses_tbl WHERE subject_id = subject_id_in;

	example-3, (Cursor with return clause)
	SYNTAX IS:
	CURSOR cursor_name RETURN field%ROWTYPE IS SELECT_statement;

		CURSOR c3
		RETURN courses_tbl%ROWTYPE
		IS
		SELECT *
		FROM courses_tbl
		WHERE subject = 'Mathematics';	 -- all columns from the course_tbl where the subject is Mathematics.
		
2) Open a cursor: in order to use a cursor, first we will have to open a cursor. SYNTAX: OPEN cursor_name;
	
3) Fetch a cursor: fetch rows from your cursor.
	SYNTAX IS: FETCH cursor_name INTO variable_list; where variable_list is the list of variables, comma delimited, that you wish to store the cursor result set in.
	
	example,
		CURSOR c1
		IS
		SELECT course_number
		FROM courses_tbl
		WHERE course_name = name_in;
		
		FETCH c1 into cnumber;
		
4) Close a cursor: CLOSE cursor_name;

5) cursor attributes: is used to determine the status of your cursor.
%ISOPEN   : Returns TRUE if the cursor is open, FALSE if the cursor is closed.
%FOUND    : Returns TRUE if a successful fetch has been executed. FALSE when no row is returned.
%NOTFOUND : Returns FALSE if a successful fetch has been executed. Returns TRUE if no row was returned.i.e. OPPOSITE of $FOUND
%ROWCOUNT : doesn't give the real row count until you have iterated through the entire cursor. DO NOT RELY.


example-1,
	CREATE OR REPLACE Function FindCourse
	   ( name_in IN varchar2 )
	   RETURN number
	IS
	   cnumber number;

	   CURSOR c1
	   IS
	   SELECT course_number FROM courses_tbl WHERE course_name = name_in;

	BEGIN
	   OPEN c1;
	   FETCH c1 INTO cnumber;

	   if c1%notfound then
		  cnumber := 9999;
	   end if;

	   CLOSE c1;

	RETURN cnumber;

	END;
	
example-2 (Cursors with SELECT FOR UPDATE)
SYNTAX:
CURSOR cursor_name IS select_statement FOR UPDATE [OF column_list] [NOWAIT];
here, NOWAIT is Optional. The cursor does not wait for resources.
This feature allows you to lock the records in the cursor result set. The record locks are released when the next commit or rollback statement is issued.

NOTE: You are not required to make changes to the records in order to use this statement.
	 
	CURSOR c1
	IS
	SELECT course_number, instructor
	FROM courses_tbl
	FOR UPDATE OF instructor;  
	
example-3 (WHERE CURRENT OF)
WHERE CURRENT OF is used for updating or deleting records that have been referenced by a SELECT FOR UPDATE statement.

SYNTAX IS:
UPDATE table_name SET set_clause WHERE CURRENT OF cursor_name;
OR
DELETE FROM table_name WHERE CURRENT OF cursor_name;

Sample code:
	CREATE OR REPLACE Function FindCourse
	   ( name_in IN varchar2 )
	   RETURN number
	IS
	   cnumber number;

	   CURSOR c1
	   IS
		 SELECT course_number
		 FROM courses_tbl
		 WHERE course_name = name_in
		 FOR UPDATE of instructor;

	BEGIN

	   OPEN c1;
	   FETCH c1 INTO cnumber;

	   if c1%notfound then
		  cnumber := 9999;

	   else
		  UPDATE courses_tbl
			SET instructor = 'SMITH'
			WHERE CURRENT OF c1;

		  COMMIT;

	   end if;

	   CLOSE c1;

	RETURN cnumber;

	END;
	
Other sample code:
	CREATE OR REPLACE Function FindCourse
	   ( name_in IN varchar2 )
	   RETURN number
	IS
	   cnumber number;

	   CURSOR c1
	   IS
	   SELECT course_number
	   from courses_tbl
	   where course_name = name_in
	   FOR UPDATE of instructor;

	BEGIN

	   open c1;
	   fetch c1 into cnumber;

	   if c1%notfound then
		  cnumber := 9999;

	   else
		  DELETE FROM courses_tbl
			WHERE CURRENT OF c1;

		  COMMIT;

	   end if;

	   close c1;

	RETURN cnumber;

	END;
	
example-4 (Cursor within a cursor)
	CREATE OR REPLACE PROCEDURE MULTIPLE_CURSORS_PROC is
	   v_owner varchar2(40);
	   v_table_name varchar2(40);
	   v_column_name varchar2(100);

	   /* First cursor */
	   CURSOR get_tables IS
		 SELECT DISTINCT tbl.owner, tbl.table_name
		 FROM all_tables tbl
		 WHERE tbl.owner = 'SYSTEM';

	   /* Second cursor */
	   CURSOR get_columns IS
		 SELECT DISTINCT col.column_name
		 FROM all_tab_columns col
		 WHERE col.owner = v_owner
		 AND col.table_name = v_table_name;

	   BEGIN

	   -- Open first cursor
	   OPEN get_tables;
	   LOOP
		  FETCH get_tables INTO v_owner, v_table_name;

		  -- Open second cursor
		  OPEN get_columns;
		  LOOP
			 FETCH get_columns INTO v_column_name;
		  END LOOP;

		  CLOSE get_columns;

	   END LOOP;

	   CLOSE get_tables;

	EXCEPTION
	   WHEN OTHERS THEN
		  raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);
	end MULTIPLE_CURSORS_PROC;
	
	
-------------------
difference between %ROWTYPE and TYPE RECORD?
%ROWTYPE is used whenever query returns an entire row of a table or view.
TYPE RECORD is used whenever query returns columns of different table or views and variables.

example %ROWTYPE:
	CURSOR c3
	RETURN courses_tbl%ROWTYPE
	IS
	SELECT *
	FROM courses_tbl
	WHERE subject = 'Mathematics';	 -- all columns from the course_tbl where the subject is Mathematics.
	
example %TYPE:
	DECLARE 
	   type books is record 
		  (title varchar(50), 
		  author varchar(50), 
		  subject varchar(100), 
		  book_id number); 
	   book1 books; 
	   book2 books; 
	BEGIN 
	   -- Book 1 specification 
	   book1.title  := 'C Programming'; 
	   book1.author := 'Nuha Ali ';  
	   book1.subject := 'C Programming Tutorial'; 
	   book1.book_id := 6495407;  
	   -- Book 2 specification 
	   book2.title := 'Telecom Billing'; 
	   book2.author := 'Zara Ali'; 
	   book2.subject := 'Telecom Billing Tutorial'; 
	   book2.book_id := 6495700;  
	  
	  -- Print book 1 record 
	   dbms_output.put_line('Book 1 title : '|| book1.title); 
	   dbms_output.put_line('Book 1 author : '|| book1.author); 
	   dbms_output.put_line('Book 1 subject : '|| book1.subject); 
	   dbms_output.put_line('Book 1 book_id : ' || book1.book_id); 
	   
	   -- Print book 2 record 
	   dbms_output.put_line('Book 2 title : '|| book2.title); 
	   dbms_output.put_line('Book 2 author : '|| book2.author); 
	   dbms_output.put_line('Book 2 subject : '|| book2.subject); 
	   dbms_output.put_line('Book 2 book_id : '|| book2.book_id); 
	END; 
	/
	
	O/p:
	Book 1 title : C Programming 
	Book 1 author : Nuha Ali 
	Book 1 subject : C Programming Tutorial 
	Book 1 book_id : 6495407 
	Book 2 title : Telecom Billing 
	Book 2 author : Zara Ali 
	Book 2 subject : Telecom Billing Tutorial 
	Book 2 book_id : 6495700  
	
-----------------------------
Types of cursors:
1) Implicit cursors: Whenever a DML statement (INSERT, UPDATE and DELETE) is issued, an implicit cursor is associated with this statement. 
                    For INSERT operations, the cursor holds the data that needs to be inserted. 
					For UPDATE and DELETE operations, the cursor identifies the rows that would be affected.
					i.e. are automatically created by Oracle whenever an SQL statement is executed. Programmers cannot control the implicit cursors and the information in it.
					 
					However, implicit cursor (most recent) has attributes (%FOUND, %ISOPEN, %NOTFOUND, and %ROWCOUNT)
					 
					example,
						DECLARE  
						   total_rows number(2); 
						BEGIN 
						   UPDATE customers 
						   SET salary = salary + 500; 
						   IF sql%notfound THEN 
							  dbms_output.put_line('no customers selected'); 
						   ELSIF sql%found THEN 
							  total_rows := sql%rowcount;
							  dbms_output.put_line( total_rows || ' customers selected '); 
						   END IF;  
						END; 
						/  

					O/p:
					6 customers selected.
					
2)  Explicit cursors: programmer-defined cursors (as explained in this section)

#####################################################################################################
Union, Union all, Intersect, minus:

Union, Union all, Intersect, minus ARE also called SET-OPERATORS i.e. compound two or more queries.

1) UNION: used to combine the result sets of 2 or more SELECT statements. BY DEFAULT, it removes DUPLICATE ROWS between select statements.
	      EACH SELECT STATEMENT WITHIN THE UNION MUST HAVE THE SAME NUMBER OF FIELDS IN THE RESULT SETS WITH SIMILAR DATA TYPES.
		  
		  SYNTAX IS:
			SELECT expression1, expression2, ... expression_n
			FROM tables
			[WHERE conditions]
			UNION
			SELECT expression1, expression2, ... expression_n
			FROM tables
			[WHERE conditions];
			
		expression1, expression2, expression_n: columns or calculations that you wish to retrieve.
		
		Prerequisits for UNION to work fine:
		a) There must be same number of expressions in both SELECT statements.
		b) The corresponding expressions must have the same data type in the SELECT statements
		   ex, expression1 must be the same data type in both the first and second SELECT statement.
		c) Column headings in the result set will be from the 1st table in the UNION.
		   
	example-Inputs:
	suppliers table,
	supplier_id	supplier_name
	1000		Microsoft
	2000		Oracle
	3000		Apple
	4000		Samsung

	orders table,
	order_id	order_date	supplier_id
	1			2015-08-01	2000
	2			2015-08-01	6000
	3			2015-08-02	7000
	4			2015-08-03	8000
	
	company table,
	company_id	company_name
	1000		Microsoft
	3000		Apple
	7000		Sony
	8000		IBM
	
	example-1,
		SELECT supplier_id
		FROM suppliers
		UNION
		SELECT supplier_id
		FROM orders
		ORDER BY supplier_id;
		
		O/p:
		supplier_id
		1000
		2000
		3000
		4000
		6000
		7000
		8000
		
	example-2,
		SELECT supplier_id, supplier_name
		FROM suppliers
		WHERE supplier_id > 2000
		UNION
		SELECT company_id, company_name
		FROM companies
		WHERE company_id > 1000
		ORDER BY 1;   -- will order the result by supplier_id, company_id.
		
		O/p:
		supplier_id	supplier_name  
		3000		Apple
		4000		Samsung
		7000		Sony
		8000		IBM
		
2) UNIONALL: same as UNION, but it includes duplicates from both the tables.
	example-1,
		SELECT supplier_id
		FROM suppliers
		UNION ALL
		SELECT supplier_id
		FROM orders
		ORDER BY supplier_id;
		
		O/p:
		supplier_id
		1000
		2000
		2000
		3000
		4000
		6000
		7000
		8000
		
	example-2,
		SELECT supplier_id, supplier_name
		FROM suppliers
		WHERE supplier_id > 2000
		UNION ALL
		SELECT company_id, company_name
		FROM companies
		WHERE company_id > 1000
		ORDER BY 1;
		
		O/p:
		supplier_id	supplier_name
		3000		Apple
		3000		Apple
		4000		Samsung
		7000		Sony
		8000		IBM
		
3) INTERSECT: will return rows common to 2 or more select statements.
	SYNTAX,
		SELECT expression1, expression2, ... expression_n
		FROM tables
		[WHERE conditions]
		INTERSECT
		SELECT expression1, expression2, ... expression_n
		FROM tables
		[WHERE conditions];
		
	example-1,
		SELECT supplier_id
		FROM suppliers
		INTERSECT
		SELECT supplier_id
		FROM orders;
		
	example-2,
		SELECT contact_id, last_name, first_name
		FROM contacts
		WHERE last_name <> 'Anderson'
		INTERSECT
		SELECT customer_id, last_name, first_name
		FROM customers
		WHERE customer_id < 50
		ORDER BY 2;  -- will order by the last_name
		
4) MINUS: return all rows in the first SELECT statement that are not returned by the second SELECT statement
		  i.e.  These are the records that exist in Dataset1 and not in Dataset2.
		  
		  NOTE: it must meet all criteria prerequisite for UNION.

#####################################################################################################
Deleting Duplicate rows in a table:
1) via rowid:
	DELETE FROM table_name A
	WHERE a.rowid > ANY (
	SELECT B.rowid FROM table_name B
	WHERE 
	A.col1 = B.col1 AND 
	A.col2 = B.col2
	); 
	
2) via self join as,
	DELETE FROM
	select book_unique_id, page_seq_nbr, image_key 
	from page_image a 
	where 
	   rowid > 
		 (select min(rowid) from page_image b 
		  where b.key1 = a.key1 and 
		  b.key2 = a.key2 and 
		  b.key3 = a.key3 
		 ); 
		 
	NOTE: you must specify all of the columns that make the row a duplicate in the SQL where clause.
	
3) via self join anf no rowid
	SELECT t1.entity_id, t1.station_id, t1.obs_year
	FROM mytable t1
	INNER JOIN (
	SELECT station_id, obs_year FROM mytable 
	GROUP BY station_id, obs_year HAVING COUNT(*) > 1) dupes 
	ON 
	t1.station_id = dupes.station_id AND
	t1.obs_year = dupes.obs_year
	
##################################################################################
Constraints:
Rule to which data must conform. It is an optional part of a CREATE TABLE statement or ALTER TABLE statement.
There are 2 kind of constraints:
1) column constraint
2) table constraint

column constraint comprises of:
	NOT NULL	 
	PRIMARY KEY
	UNIQUE 
	FOREIGN KEY 
	CHECK 
	
Table constraint comprises of:
	PRIMARY KEY 
	UNIQUE
	FOREIGN KEY
	CHECK 

CREATE TABLE SAMP.OUT_TRAY
(
SENT TIMESTAMP,
DESTINATION CHAR(8),
SUBJECT CHAR(64) NOT NULL CONSTRAINT PRIMARY KEY,    -- column level primary key
NOTE_TEXT VARCHAR(3000) 
);

CREATE TABLE SAMP.EMP 
(
EMPNO CHAR(6) NOT NULL CONSTRAINT EMP_PK PRIMARY KEY,
FIRSTNME CHAR(12) NOT NULL,
MIDINIT vARCHAR(12) NOT NULL,
LASTNAME VARCHAR(15) NOT NULL,
SALARY DECIMAL(9,2) CONSTRAINT SAL_CK CHECK (SALARY >= 10000),  --column level check constraint
BONUS DECIMAL(9,2), 
TAX DECIMAL(9,2),
CONSTRAINT BONUS_CK CHECK (BONUS > TAX)    -- table level check
);

CREATE TABLE FLIGHTS
	(
	FLIGHT_ID CHAR(6) NOT NULL ,
	SEGMENT_NUMBER INTEGER NOT NULL ,
	ORIG_AIRPORT CHAR(3),
	DEPART_TIME TIME,
	DEST_AIRPORT CHAR(3),
	ARRIVE_TIME TIME,
	MEAL CHAR(1) CONSTRAINT MEAL_CONSTRAINT  CHECK (MEAL IN ('B', 'L', 'D', 'S')),   --column level check  
	PRIMARY KEY (FLIGHT_ID, SEGMENT_NUMBER)
	);

   
table constraint comprises of:
CREATE TABLE SAMP.SCHED 
(
CLASS_CODE CHAR(7) NOT NULL, 
DAY SMALLINT NOT NULL, 
STARTING TIME, 
ENDING TIME,
PRIMARY KEY (CLASS_CODE, DAY)
);

CREATE TABLE SAMP.EMP 
(
EMPNO CHAR(6) NOT NULL CONSTRAINT EMP_PK PRIMARY KEY,
FIRSTNME CHAR(12) NOT NULL,
MIDINIT vARCHAR(12) NOT NULL,
LASTNAME VARCHAR(15) NOT NULL,
SALARY DECIMAL(9,2) CONSTRAINT SAL_CK CHECK (SALARY >= 10000),  --column level check constraint
BONUS DECIMAL(9,2), 
TAX DECIMAL(9,2),
CONSTRAINT BONUS_CK CHECK (BONUS > TAX)    -- table level check
);

ALTER TABLE SAMP.PROJECT ADD CONSTRAINT P_UC UNIQUE (PROJNAME);

CREATE TABLE Orders (
    OrderID int NOT NULL PRIMARY KEY,
    OrderNumber int NOT NULL,
    PersonID int FOREIGN KEY REFERENCES Persons(PersonID)   --FOREIGN KEY on the "PersonID" column when the "Orders" table is created 
);

ALTER TABLE Orders ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID); 


Integrity constraint: to implement a business rule accurately in a table. There are 2 : domain and referential integrity constraints

referential integrity constraints include (check, PK, not null)

#####################################################################################################
SUBSTR and INSTR:
SUBSTR returns specific portion of a string and INSTR provides character position in which a pattern is found in a string.
SUBSTR returns string whereas INSTR returns numeric.

SUBSTR: extracts a substring from a string.
		SYNTAX IS: substr( string, start_position, [ length ] )
        where, length is optional. It is the number of characters to extract. If this parameter is omitted, substr will return the entire string.
		Note:
		If start_position is 0, then substr treats start_position as 1 (ie: the first position in the string).
		If start_position is a positive number, then substr starts from the beginning of the string.
		If start_position is a negative number, then substr starts from the end of the string and counts backwards.

		If length is a negative number, then substr will return a NULL value.
		
		example:
		substr('This is a test', 6, 2) would return 'is' 
		substr('This is a test', 6) would return 'is a test' 
		substr('TechOnTheNet', 1, 4) would return 'Tech' 
		substr('TechOnTheNet', -3, 3) would return 'Net' 
		substr('TechOnTheNet', -6, 3) would return 'The' 
		substr('TechOnTheNet', -8, 2) would return 'On' 

INSTR: returns the location of a substring in a string.
	   SYNTAX IS: INSTR( string, substring [, start_position [, nth_appearance ] ] )
	   nth_appearance is Optional. The nth appearance of substring. If omitted, it defaults to 1
	   returns a numeric value. 
	   a) The first position in the string is 1.
	   b) If substring is not found in string, then the INSTR function will return 0.
	   
		example,
		INSTR('Tech on the net', 'e')
		Result: 2   (the first occurrence of 'e')

		INSTR('Tech on the net', 'e', 1, 1)
		Result: 2   (the first occurrence of 'e')

		INSTR('Tech on the net', 'e', 1, 2)
		Result: 11  (the second occurrence of 'e')

		INSTR('Tech on the net', 'e', 1, 3)
		Result: 14  (the third occurrence of 'e')

		INSTR('Tech on the net', 'e', -3, 2)
		Result: 2
	   
########################################################################################################
Oracle Triggers:

You can define procedures that are implicitly executed when an INSERT, UPDATE or DELETE statement is issued against the associated table. 
These procedures are called database triggers.

parts of a database trigger:
A triggering event or statement
A trigger restriction
A trigger action

six CREATE TRIGGER statements according to their firing points:
Firing Point: BEFORE
1) BEFORE INSERT TRIGGER
	Syntax is:
		CREATE [ OR REPLACE ] TRIGGER trigger_name
		BEFORE INSERT
		ON table_name
	    [ FOR EACH ROW ]
		
	example,
		CREATE TABLE orders
		( order_id number(5),
		  quantity number(4),
		  cost_per_item number(6,2),
		  total_cost number(8,2),
		  create_date date,
		  created_by varchar2(10)
		);

		CREATE OR REPLACE TRIGGER orders_before_insert
		BEFORE INSERT
		   ON orders
		   FOR EACH ROW

		DECLARE
		   v_username varchar2(10);

		BEGIN

		   -- Find username of person performing INSERT into table
		   SELECT user INTO v_username FROM dual;

		   -- Update create_date field to current system date
		   :new.create_date := sysdate;

		   -- Update created_by field to the username of the person performing the INSERT
		   :new.created_by := v_username;

		END;



2) BEFORE UPDATE TRIGGER
	example,
		CREATE OR REPLACE TRIGGER orders_before_update
		BEFORE UPDATE
		ON orders
		FOR EACH ROW

3) BEFORE DELETE TRIGGER
	example,
		CREATE OR REPLACE TRIGGER orders_before_delete
		BEFORE DELETE
		ON orders
		FOR EACH ROW

Firing Point: AFTER
1) AFTER INSERT TRIGGER
	example,
		CREATE OR REPLACE TRIGGER orders_after_insert
		AFTER INSERT
		   ON orders
		   FOR EACH ROW

		DECLARE
		   v_username varchar2(10);

		BEGIN

		   -- Find username of person performing the INSERT into the table
		   SELECT user INTO v_username
		   FROM dual;

		   -- Insert record into audit table
		   INSERT INTO orders_audit
		   ( order_id,
			 quantity,
			 cost_per_item,
			 total_cost,
			 username )
		   VALUES
		   ( :new.order_id,
			 :new.quantity,
			 :new.cost_per_item,
			 :new.total_cost,
			 v_username );

		END;

2) AFTER UPDATE TRIGGER
	example,
		CREATE OR REPLACE TRIGGER orders_after_update
		AFTER UPDATE
		ON orders
		FOR EACH ROW

3) AFTER DELETE TRIGGER
	example,
		CREATE OR REPLACE TRIGGER orders_after_delete
		AFTER DELETE
		ON orders
		FOR EACH ROW
 
-----
Difference between trigger and stored procedure? 
Trigger in act which is performed automatically before or after a event occur when DML operations are occur Trigger is Fired.
Stored procedure is a set of functionality which is executed when it is explicitly invoked.

-----
What are cascading triggers? What is the maximum no of cascading triggers at a time?
When a statement in a trigger body causes another trigger to be fired, the triggers are said to be cascading.Max = 32.

What are mutating triggers ?
A trigger giving a SELECT on the table on which the trigger is written.

What are constraining triggers ?
A trigger giving an Insert/Updat e on a table having referential integrity constraint on the triggering table.

########################################################################################################
Oracle Index:
An index is a performance-tuning method of allowing faster retrieval of records. Indexes can be created on multiple columns.

SYNTAX to create index:
	CREATE [UNIQUE] INDEX index_name
	ON table_name (column1, column2, ... column_n)
	[ COMPUTE STATISTICS ];

	where,
	UNIQUE will ensure combination of values in the indexed columns must be unique.
	COMPUTE STATISTICS tells Oracle to collect statistics during the creation of the index. 
					   The statistics are then used by the optimizer to choose a "plan of execution" when SQL statements are executed.
				   
	example,
	CREATE INDEX supplier_idx ON supplier (supplier_name); //created an index on the supplier table called supplier_idx.
	CREATE INDEX supplier_idx ON supplier (supplier_name, city) COMPUTE STATISTICS; 

SYNTAX to rename an index:
	ALTER INDEX index_name RENAME TO new_index_name;
		   
	example,
	ALTER INDEX supplier_id RENAME TO supplier_index_name;
	
SYNTAX to drop an index:
	DROP INDEX supplier_idx;
	
How indexing works?
Creating an index on a field in a table creates another data structure which holds the field value, and a pointer to the record it relates to. 
This index structure is then sorted, allowing Binary Searches to be performed on it.

The downside to indexing is that indexes require additional space on the disk since the indexes are stored together in a table

When to create index: 
when table is queried for less than 2% or 4% to 25% of the table rows.

How can we avoid index in case indexes already exist on columns without deleting the indexes?
example,
create table t1(id varhcar2(10),data1 varchar2(3000));
create table t2(id varhcar2(10),data2 varchar2(3000));

create index id1 on t1(id);

select * from t1,t2 where t1.id=t2.id;

to avoid index, we can use NO_INDEX hint,
SELECT /*+ NO_INDEX(t1 id1) */  FROM t1,t2 WHERE t1.id = t2.id;

############################################################################################################

Data file: 
A database’s data files contain all the database data. The data of logical database structures is tables and indexes is physically stored in the data files allocated for a database.


difference between UNIQUE and PRIMARY KEY?
A column defined as PRIMARY KEY can contain unique values
same as UNIQUE but UNIQUE can contain NULLs while a column defined as PRIMARY KEY cannot contain NULLs.


Difference between Truncate and Delete:
Truncate is Dml Statements. Cannot be rolled back. Delete allows the filtered deletion.
Deleted records can be rolled back or committed.

Difference between PROCEDURE and FUNCTION:
A PROCEDURE may return one or more values or may not return at all.
A FUNCTION must returns a value using the return statement.

various types of parameter modes in a procedure:
IN, OUT AND INOUT.

What is Package and its advantages?
database object that groups logically related procedures.
The advantages of packages are modularity, easier application design, 
information hiding, reusability and better performance.

#############################################################################################################
Exception handling: ( details of error handling in : http://plsql-tutorial.com/plsql-exception-handling.htm )

PL/SQL Exception message consists of three parts. 
1) Type of Exception
2) An Error Code
3) A message 

general syntax-1,
	DECLARE
	   Declaration section 
	 BEGIN 
	   Exception section 
	 EXCEPTION 
	 WHEN ex_name1 THEN 
		-Error handling statements 
	 WHEN ex_name2 THEN 
		-Error handling statements 
	 WHEN Others THEN 
	   -Error handling statements 
	END; 
	

types of exception:
a) Named System Exceptions: System exceptions are automatically raised by Oracle.
	Exception Name			Reason											Error Number
	CURSOR_ALREADY_OPEN		When you open a cursor that is already open.	ORA-06511
	INVALID_CURSOR			When you perform an invalid operation on a		ORA-01001 
							cursor like closing a cursor, 
							fetch data from a cursor that is not opened.

	NO_DATA_FOUND			When a SELECT...INTO clause does not return		ORA-01403 
							any row from a table.

	TOO_MANY_ROWS			When you SELECT or fetch more than one			ORA-01422 
							row into a record or variable.

	ZERO_DIVIDE				When you attempt to divide a number by zero.	ORA-01476

	example,
	BEGIN 
	  Execution section
	EXCEPTION 
	WHEN NO_DATA_FOUND THEN 
	 dbms_output.put_line ('A SELECT...INTO did not return any row.'); 
	 END;
 
b) Unnamed System Exception: system exception for which oracle does not provide a name 
							 is known as unamed system exception. 
							 
			There are two ways to handle unnamed sysyem exceptions: 
			1. By using the WHEN OTHERS exception handler, or 
			2. By associating the exception code to a name and using it as a named exception.

			We can assign a name to unnamed system exceptions using a Pragma called EXCEPTION_INIT.
			EXCEPTION_INIT will associate a predefined Oracle error number to a programmer_defined exception name.		

		example,
		consider the product table and order_items table from sql joins.
		product_id is a primary key in product table and a foreign key in order_items table. 
		If we try to delete a product_id from the product table when it has child records in order_id table 
		an exception will be thrown with oracle code number -2292.
		
		DECLARE 
		  Child_rec_exception EXCEPTION; 
		  PRAGMA 
		  EXCEPTION_INIT (Child_rec_exception, -2292); 
		BEGIN 
		  Delete FROM product where product_id= 104; 
		EXCEPTION 
		   WHEN Child_rec_exception 
		   THEN Dbms_output.put_line('Child records are present for this product_id.'); 
		END; 
		/
					
c) User-defined Exception: exceptions based on business rules. 
	They should be explicitly declared in the declaration section. 
	They should be explicitly raised in the Execution Section. 
	They should be handled by referencing the user-defined exception name in the exception section.
	
	example,
		DECLARE 
		  huge_quantity EXCEPTION; 
		  CURSOR product_quantity is 
		  SELECT p.product_name as name, sum(o.total_units) as units
		  FROM order_tems o, product p
		  WHERE o.product_id = p.product_id; 
		  quantity order_tems.total_units%type; 
		  up_limit CONSTANT order_tems.total_units%type := 20; 
		  message VARCHAR2(50); 
		BEGIN 
		  FOR product_rec in product_quantity LOOP 
			quantity := product_rec.units;
			 IF quantity > up_limit THEN 
			  message := 'The number of units of product ' || product_rec.name ||  
						 ' is more than 20. Special discounts should be provided. 
				 Rest of the records are skipped. '
			 RAISE huge_quantity; 
			 ELSIF quantity < up_limit THEN 
			  v_message:= 'The number of unit is below the discount limit.'; 
			 END IF; 
			 dbms_output.put_line (message); 
		  END LOOP; 
		 EXCEPTION 
		   WHEN huge_quantity THEN 
			 dbms_output.put_line (message); 
		END; 

uses for RAISE_APPLICATION_ERROR in PL/SQL:

The first is to replace generic Oracle exception messages with our own, more meaningful messages.
The second is to create exception conditions of our own, when Oracle would not throw them.

error number should be in range between -20000 and -20999.

Whenever a message is displayed using RAISE_APPLICATION_ERROR, all previous transactions which are not committed 
within the PL/SQL Block are rolled back automatically (i.e. change due to INSERT, UPDATE, or DELETE statements). 

The General Syntax to use this procedure is: 
RAISE_APPLICATION_ERROR (error_number, error_message); 

example:
DECLARE
  huge_quantity EXCEPTION; 
  CURSOR product_quantity is 
  SELECT p.product_name as name, sum(o.total_units) as units
  FROM order_tems o, product p
  WHERE o.product_id = p.product_id; 
  quantity order_tems.total_units%type; 
  up_limit CONSTANT order_tems.total_units%type := 20; 
  message VARCHAR2(50); 
BEGIN 
  FOR product_rec in product_quantity LOOP 
    quantity := product_rec.units;
     IF quantity > up_limit THEN 
        RAISE huge_quantity; 
     ELSIF quantity < up_limit THEN 
      v_message:= 'The number of unit is below the discount limit.'; 
     END IF; 
     Dbms_output.put_line (message); 
  END LOOP; 
 EXCEPTION 
   WHEN huge_quantity THEN 
	raise_application_error(-2100, 'The number of unit is above the discount limit.');
 END; 
/ 

#########################################################################
Foreign key with cascade delete:
A foreign key with cascade delete means that if a record in the parent table is deleted, 
then the corresponding records in the child table will automatically be deleted.

A foreign key with a cascade delete can be defined in,
1) either a CREATE TABLE statement 
2) or an ALTER TABLE statement.

example-1, (creating FK with one field)
	1) created a primary key on the supplier table called supplier_pk. 
	2) created a foreign key called fk_supplier on the products table that references 
	   the supplier table based on the supplier_id field.
   
	CREATE TABLE supplier
	( supplier_id numeric(10) not null,
	  supplier_name varchar2(50) not null,
	  contact_name varchar2(50),
	  CONSTRAINT supplier_pk PRIMARY KEY (supplier_id)
	);

	CREATE TABLE products
	( product_id numeric(10) not null,
	  supplier_id numeric(10) not null,
	  CONSTRAINT fk_supplier
		FOREIGN KEY (supplier_id)
		REFERENCES supplier(supplier_id)
		ON DELETE CASCADE
	);

example-2, (creating a FK, with more than one field)
	CREATE TABLE supplier
	( supplier_id numeric(10) not null,
	  supplier_name varchar2(50) not null,
	  contact_name varchar2(50),
	  CONSTRAINT supplier_pk PRIMARY KEY (supplier_id, supplier_name)
	);

	CREATE TABLE products
	( product_id numeric(10) not null,
	  supplier_id numeric(10) not null,
	  supplier_name varchar2(50) not null,
	  CONSTRAINT fk_supplier_comp
		FOREIGN KEY (supplier_id, supplier_name)
		REFERENCES supplier(supplier_id, supplier_name)
		ON DELETE CASCADE
	);

example-3, (with alter table statement)
	ALTER TABLE products
	ADD CONSTRAINT fk_supplier
	  FOREIGN KEY (supplier_id)
	  REFERENCES supplier(supplier_id)
	  ON DELETE CASCADE;
	  
	ALTER TABLE products
	ADD CONSTRAINT fk_supplier
	  FOREIGN KEY (supplier_id, supplier_name)
	  REFERENCES supplier(supplier_id, supplier_name)
	  ON DELETE CASCADE;

----
Foreign Keys with Set Null on Delete:
if a record in the parent table is deleted, then the corresponding records in the child table 
will have the foreign key fields set to null. 

example-1,
	CREATE TABLE supplier
	( supplier_id numeric(10) not null,
	  supplier_name varchar2(50) not null,
	  contact_name varchar2(50),
	  CONSTRAINT supplier_pk PRIMARY KEY (supplier_id)
	);

	CREATE TABLE products
	( product_id numeric(10) not null,
	  supplier_id numeric(10),
	  CONSTRAINT fk_supplier
		FOREIGN KEY (supplier_id)
		REFERENCES supplier(supplier_id)
		ON DELETE SET NULL
	);
	
-------
Drop a foreign key:
ALTER TABLE products DROP CONSTRAINT fk_supplier;

Disable a foreign key:
ALTER TABLE products DISABLE CONSTRAINT fk_supplier;

-------
difference between foreign key and reference key ?
Foreign key is attribute which refers to another table primary key. Reference key is the primary key of table referred by another table.

################################################################################
TRIM Function in oracle:

a) TRIM: removes all specified characters either from the beginning or the end of a string.
	TRIM( [ [ LEADING | TRAILING | BOTH ] trim_character FROM ] string1 )
	
	NOTE: If you do not choose a value for the first parameter (LEADING, TRAILING, BOTH), 
	the TRIM function will remove trim_character from both the front and end of string1.
	
	example,
		TRIM('   tech   ')
		Result: 'tech'

		TRIM(' '  FROM  '   tech   ')
		Result: 'tech'

		TRIM(LEADING '0' FROM '000123')
		Result: '123'

		TRIM(TRAILING '1' FROM 'Tech1')
		Result: 'Tech'

		TRIM(BOTH '1' FROM '123Tech111')
		Result: '23Tech'
		
b) LTRIM: trim the characters from the left-hand side.
	example,
		LTRIM('   tech')
		Result: 'tech'

		LTRIM('   tech', ' ')
		Result: 'tech'

		LTRIM('000123', '0')
		Result: '123'

		LTRIM('123123Tech', '123')
		Result: 'Tech'

		LTRIM('123123Tech123', '123')
		Result: 'Tech123'

		LTRIM('xyxzyyyTech', 'xyz')
		Result: 'Tech'

		LTRIM('6372Tech', '0123456789')
		Result: 'Tech'
		
	NOTE: LTRIM function may appear to remove patterns, but this is not the case
	example,
		LTRIM('xxyyxzyxyyxTech', 'xyz')	Result: 'Tech'
		LTRIM( '637Tech', '0123456789') Result: 'Tech'

c) RTRIM: same as LTRIM except trims right hand side.

###################################################################
Oracle Savepoint:

Savepoint is a marker within a transaction that allows partial rollback.
If we encounter an error, we can rollback to a SAVEPOINT

example,
	SQL> INSERT INTO AUTHOR 
	2 VALUES ('A11l', 'john', 
	3 'garmany', '123-345-4567', 
	4 '1234 here st', 'denver', 
	5 'CO','90204', '9999');

	1 row created.

	SQL> savepoint in_author;

	Savepoint created.

	SQL> INSERT INTO BOOK_AUTHOR VALUES ('A111', 'B130', .20); 
	1 row created.

	SQL> savepoint in_book_author;

	Savepoint created.

	SQL> INSERT INTO BOOK 
	VALUES ('B130', 'P002', 'easy oracle sql', 
	'miscellaneous', 9.95, 1000, 15, 0, '', 
	to_date ('02-20-2005','MM-DD-YYYY'));
	1 row created.

	SQL> rollback to in_author;

	Rollback complete.
	
###################################################################
Top-n analysis:

i.e. How to limit the number of rows returned from ordered sets of data in SQL.

SYNTAX can be:
SELECT [column_list], ROWNUM
FROM (SELECT [column_list]
      FROM table_name
      ORDER BY Top-N_column)
WHERE ROWNUM<=N

example,

Top-n analysis can be done via,
1) Inline View and ROWNUM: i.e. force the data into the correct order which is then limited thru ROWNUM
	example,
	SELECT first_name, last_name
	FROM (SELECT first_name, last_name
		  FROM Employee
		  ORDER BY salary DESC)
	WHERE ROWNUM<=4;
	
2) Nested Inline View and ROWNUM: 
	example,
	SELECT employee_id, first_name, salary
	FROM   (SELECT employee_id, first_name, salary, rownum AS rnum
			FROM   (SELECT employee_id, first_name, salary
					FROM Employee
					ORDER BY salary)
			WHERE rownum<=4)
	WHERE  rnum>=2;
	
3) Using RANK function: The RANK analytic function assigns a sequential rank to each distinct value in output.
	example,
	SELECT dpartment_id, first_name
	FROM (SELECT dpartment_id, first_name,
		  RANK() OVER (ORDER BY dpartment_id DESC) AS rnum 
		  FROM Employee)
	WHERE rnum<=3;
	
####################################################################################################
Oracle Synonyms:
alternative name for objects such as tables, views, sequences, stored procedures, and other database objects.

You generally use synonyms when you are granting access to an object from another schema 
and you don't want the users to have to worry about knowing which schema owns the object.

CREATE [OR REPLACE] [PUBLIC] SYNONYM [schema .] synonym_name
  FOR [schema .] object_name [@ dblink];
  
example-1,(create a synonym called suppliers)
CREATE PUBLIC SYNONYM suppliers FOR app.suppliers;
so,
users of other schemas can reference the table called suppliers without having to prefix the table name with the schema named app.

to drop this synonym:
DROP PUBLIC SYNONYM suppliers;

difference between a view and a synonym ?
Synonym is Schema Object,just a second name of table,.View can be created with many tables, and with virtual columns and with conditions.

#######################################################################################################
Oracle Hints:

https://www.red-gate.com/simple-talk/sql/oracle/a-beginners-guide-to-optimizer-hints/


#######################################################################################################
Rollback segments:

Rollback statement is used to undo the changes made by the DML statements, to the last commit point of the oracle. 
Now, rollback segment is that segment which keeps a copy of last commit point and can be restored upon using rollback statement.

#######################################################################################################
SQL functions:

are entities which can take argument and return some value.

there are 2 types of SQL functions:
1) Single-Row functions: These functions operate on a single row to give one result per row.
	example: to_date, to_char.....
2) Multiple-Row functions: These functions operate on groups of rows to give one result per group of rows.
	example: AVG,COUNT,MAX,MIN,SUM.
	
Character functions: accept character input and return both character and number values. Types of character function are:
			a) Case-Manipulation Functions: LOWER, UPPER, INITCAP
			b) Character-Manipulation Functions: CONCAT, SUBSTR, LENGTH, INSTR, LPAD/RPAD, TRIM, REPLACE

Number Functions: accept Numeric input and return numeric values. Number Functions are: ROUND, TRUNC and MOD

Date Functions: operates on values of the Date data type. 
                (All date functions return a value of DATE data type except the MONTHS_BETWEEN Function, which returns a number. 
				Date Functions are MONTHS_BETWEEN, ADD_MONTHS, NEXT_DAY, LAST_DAY, ROUND, TRUNC. 

-----
Conversion functions:
converts a value from one data type to another. There are 2 types:
1) Implicit data type conversion. example,
	VARCHAR2 or CHAR To NUMBER, DATE
	NUMBER To VARCHAR2
	DATE To VARCHAR2
	
2) Explicit data type conversion.
	a) TO_NUMBER: SYNTAX IS: TO_NUMBER( string1 [, format_mask])
		where,
		format_mask: Optional. This is the format that will be used to convert string1 to a number.

		example,
		TO_NUMBER('1210.73', '9999.99')  // Result: 1210.73

		TO_NUMBER('546', '999') 		 // Result: 546

		TO_NUMBER('23', '99') 			// Result: 23

		TO_NUMBER('1210.73')  			// Result: 1210.73

	b) TO_CHAR: converts a number or date to a string. SYNTAX IS: TO_CHAR( value [, format_mask])
		example-1 (number examples),
		TO_CHAR(1210.73, '9999.9')		//Result: ' 1210.7'

		TO_CHAR(-1210.73, '9999.9')		//Result: '-1210.7'

		TO_CHAR(1210.73, '9,999.99')	//Result: ' 1,210.73'

		TO_CHAR(1210.73, '$9,999.00')	//Result: ' $1,210.73'

		TO_CHAR(21, '000099')			//Result: ' 000021'
		
		example-2 (date examples),
		TO_CHAR(sysdate, 'yyyy/mm/dd')
		Result: '2003/07/09'

		TO_CHAR(sysdate, 'Month DD, YYYY')
		Result: 'July 09, 2003'

		TO_CHAR(sysdate, 'FMMonth DD, YYYY')
		Result: 'July 9, 2003'

		TO_CHAR(sysdate, 'MON DDth, YYYY')
		Result: 'JUL 09TH, 2003'

		TO_CHAR(sysdate, 'FMMON DDth, YYYY')
		Result: 'JUL 9TH, 2003'

		TO_CHAR(sysdate, 'FMMon ddth, YYYY')
		Result: 'Jul 9th, 2003'
				
		TO_CHAR(sysdate, 'FMMonth DD, YYYY')
		Result: 'July 9, 2003'

		TO_CHAR(sysdate, 'FMMON DDth, YYYY')
		Result: 'JUL 9TH, 2003'

		TO_CHAR(sysdate, 'FMMon ddth, YYYY')
		Result: 'Jul 9th, 2003'
		
		NOTE: if the format_mask parameter begins with "FM". This means that zeros and blanks are suppressed.
	

	c) TO_DATE:  converts a string to a date.
		example,
		TO_DATE('2003/07/09', 'yyyy/mm/dd')
		Result: date value of July 9, 2003

		TO_DATE('070903', 'MMDDYY')
		Result: date value of July 9, 2003

		TO_DATE('20020315', 'yyyymmdd')
		Result: date value of Mar 15, 2002
		
		SELECT TO_DATE('2015/05/15 8:30:25', 'YYYY/MM/DD HH:MI:SS') FROM dual;
		Result: 2015/05/15 8:30:25 to a date value.

----
Question: Why doesn't this sort the days of the week in order?
	SELECT ename, hiredate, TO_CHAR((hiredate),'fmDay') "Day"
	FROM emp
	ORDER BY "Day";
Answer: In the above SQL, the fmDay format mask used in the TO_CHAR function will return the name of the Day and not the numeric value of the day.
To sort the days of the week in order, you need to return the numeric value of the day by using the fmD format mask as follows:
	SELECT ename, hiredate, TO_CHAR((hiredate),'fmD') "Day"
	FROM emp
	ORDER BY "Day";
	
----
General Function used in SQL:
NVL:  Converts a null value to an actual value.

NVL2: If exp1 is not null, nvl2 returns exp2, if exp1 is null, nvl2 returns exp3. NVL2 (exp1, exp2, exp3)
	  example,
	  select NVL2(supplier_city, 'Completed', 'n/a') from suppliers;
	  will return 'Completed' if supplier_city is NOT NULL and 'n/a' if NULL

NULLIF: Compares two expressions and returns null if they are equal or the first expression if they are not equal. NULLIF (exp1, exp2)

COALESCE: Returns the first non-null expression in the expression list

Conditional Expressions.

	
###############################################################################
COUNT in Oracle:

1) COUNT(*)   : Returns number of rows in a table including duplicates rows and rows containing null values in any of the columns.
2) COUNT(exp) : will ONLY include count where exp is NOT NULL.
                example,
				supplier_id	supplier_name	state
				1			IBM				CA
				2			Microsoft
				3			NVIDIA

				so,
				SELECT COUNT(supplier_id) FROM suppliers;   //will return 3
				SELECT COUNT(state) FROM suppliers;         //will return 1
				
3) COUNT(DISTINCT exp): Returns the number of unique, non-null values in the column.
						example,
						SELECT COUNT(DISTINCT department) AS "Unique departments" FROM employees WHERE salary > 55000;
						
4) COUNT with group_by: 
						example,
						SELECT department, COUNT(*) AS "Number of employees"
						FROM employees
						WHERE state = 'CA'
						GROUP BY department;

################################################################################
use of single Ampersand (&&) and Double Ampersand (&&) in SQL Queries:

Both of these are substitution variable 

"&" ---> the variable prefixed with an ampersand (&) to prompt the user for a value.
			eg:
			SELECT employee_id, last_name, salary, department_id
			FROM employees
			WHERE employee_id = &employee_num ;

			It should prompt the user to enter a value for employee_num


"&&" ---> Mainly we used the double-ampersand (&&) if you want to reuse the variable value without prompting the user each time.
			eg:
			SELECT employee_id, last_name, job_id, &&column_name
			FROM employees
			ORDER BY &column_name;

			Here the user is asked to give the value for variable column_name only once. 
			The value supplied by the user (department_id) is used both for display and ordering of data.
