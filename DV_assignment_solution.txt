    val sc = new SparkContext("local[*]", "PopularMoviesNicer")  
    
    // Create a broadcast variable of our ID -> movie name map
    var nameDict = sc.broadcast(loadMovieNames)
    
    // Read in each rating line
    val lines = sc.textFile("../ml-100k/u.data")
    
    // Map to (movieID, 1) tuples
    val movies = lines.map(x => (x.split("\t")(1).toInt, 1))
    
    // Count up all the 1's for each movie
    val movieCounts = movies.reduceByKey( (x, y) => x + y )
    
    // Flip (movieID, count) to (count, movieID)
    val flipped = movieCounts.map( x => (x._2, x._1) )
    
    // Sort
    val sortedMovies = flipped.sortByKey()
    
    // Fold in the movie names from the broadcast variable
    val sortedMoviesWithNames = sortedMovies.map( x  => (nameDict.value(x._2), x._1) )
    
    // Collect and print results
    val results = sortedMoviesWithNames.collect()

------------------------------------------------------------	
	
val rdd_data = sc.textFile("sb_sparkCore_assgmnt_ds/u.data")
val rdd_item = sc.textFile("sb_sparkCore_assgmnt_ds/u.item")

val rdd_item_split = rdd_item.map { x =>
val arr = x.split('|')
val mv_id = arr(0)
val mv_name = arr(1)
(mv_id,mv_name)
}

val nameDict = sc.broadcast(rdd_item_split.collectAsMap())
val movies = rdd_data.map(x => (x.split("\t")(1).toInt, 1))
val movieCounts = movies.reduceByKey( (x, y) => x + y )
val flipped = movieCounts.map( x => (x._2, x._1) )
val sortedMovies = flipped.sortByKey(false)
val sortedMoviesWithNames = sortedMovies.map( x  => (nameDict.value(x._2.toString), x._1) )
-------------------------------------------------------------