Pro*C:
Oracle's embedded SQL environment is called Pro*C i.e. It allows you to execute any SQL statement from an application program.

what is Embedded SQL environment? method of combining the computing power of a high-level language like C/C++ and the database manipulation capabilities of SQL.

A Pro*C program is compiled in two steps:
1) Pro*C precompiler recognizes the SQL statements and replaces them with appropriate calls to the functions in the SQL runtime library. 
2) regular C/C++ compiler is used to compile the code and produces the executable

Pro*C Syntax:
1) SQL: statements need to start with EXEC SQL and end with ";".
		SQL statements anywhere within a C/C++ block BUT declarative statements do not come after the executable statements.
		example,	
				{
					int a;
					/* ... */
					EXEC SQL SELECT salary INTO :a
							 FROM Employee
							 WHERE SSN=876543210;
					/* ... */
					printf("The salary is %d\n", a);
					/* ... */
				}
				
2) Preprocessor Directives: Pro*C only recognizes #include and #if. It does not recognize #define.

3) Statement Labels: 
					example,
							EXEC SQL WHENEVER SQLERROR GOTO error_in_SQL;
								/* ... */
							error_in_SQL:
								/* do error handling */
								
4) HOST Variables: holds communication between host program and the database.Host Variables are regular C variables. These can be placed with regular C Variables.
	Valid Host Variables include, char, char[n], int, short, long, float, double, VARCHAR[n]
	
	Note: VARCHAR[n] recognized by the Pro*C precompiler. It is used to represent blank-padded, variable-length strings.
		  Pro*C precompiler will convert it into a structure with a 2-byte length field and a n-byte character array.
		  
	A host variable reference must be prefixed with a colon ":" in SQL statements BUT NOT in C statements.
	C function calls and most of the pointer arithmetic expressions cannot be used as host variable.
	single quotes must be omitted When specifying a string literal via a host variable
	
	example,
	int deptnos[3] = { 000, 111, 222 };
	int get_deptno() { return deptnos[2]; }
	int *get_deptnoptr() { return &(deptnos[2]); }
	int main() {
		int x; char *y; int z;
		/* ... */
		EXEC SQL INSERT INTO emp(empno, ename, deptno) VALUES(:x, :y, :z);                  /* LEGAL */
		EXEC SQL INSERT INTO emp(empno, ename, deptno)
			VALUES(:x + 1,              										   			/* LEGAL: the reference is to x */
				   'Big Shot',                                                     			/* LEGAL: but not really a host var */
				   :deptnos[2]);                                                   		  	/* LEGAL: array element is fine */
		EXEC SQL INSERT INTO emp(empno, ename, deptno) VALUES(:x, :y,:(*(deptnos+2)));    	/* ILLEGAL: for *(deptnos+2) */
		EXEC SQL INSERT INTO emp(empno, ename, deptno) VALUES(:x, :y,:get_deptno());        /* ILLEGAL: no function calls */
		EXEC SQL INSERT INTO emp(empno, ename, deptno) VALUES(:x, :y,
				   :(*get_depnoptr())); 													/* ILLEGAL: although it has an lvalue */
		/* ... */
	}

5) Pointers: pointers declared using the regular C syntax can be used in embedded SQL statements
	example,
	    int *x;
		EXEC SQL SELECT xyz INTO :x FROM ...;
		
6) Structures: 
	example,
			typedef struct {
				char name[21];    /* one greater than column length; for '\0' */
				int SSN;
			} Emp;
			/* ... */
			Emp bigshot;
			/* ... */
			EXEC SQL INSERT INTO emp (ename, eSSN) VALUES (:bigshot);
	
7) Arrays: Arrays can only be single dimensional
	examples,
			int emp_number[50];
			char name[50][11];
			/* ... */
			EXEC SQL INSERT INTO emp(emp_number, name) VALUES (:emp_number, :emp_name);
	
	NOTE: Pro*C actually considers name a one-dimensional array of strings rather than a two-dimensional array of characters.
		  arrays of structures is also allowed.
		  
	When using arrays to store the results of a query, if the size of the host array (say n) is smaller than the actual number of tuples returned by the 
	query, then only the first n result tuples will be entered into the host array. 
	
8) Indicator Variables:   ************IGNORED BUT GOOD TO KNOW**************
	Indicator variables are "NULL flags" attached to host variables
	An indicator variable must be defined as a 2-byte integer ex, (short indicator_var;) and can be declared as,
	a)  prefixed by a colon and immediately follow its host variable.
	b) keyword INDICATOR in between the host variable and indicator variable.
	
	example,
			short indicator_var;
			EXEC SQL SELECT xyz INTO :host_var:indicator_var
				FROM ...;
			/* ... */
			EXEC SQL INSERT INTO R VALUES(:host_var INDICATOR :indicator_var, ...);

	SO, You can use indicator variables in the INTO clause of a SELECT statement to detect NULL's or truncated values in the output host variables
	-1 The column value is NULL, so the value of the host variable is indeterminate. 
	 0 Oracle assigned an intact column value to the host variable. 
	>0 Oracle assigned a truncated column value to the host variable. The integer returned by the indicator variable is the original length of the column value. 
	-2 Oracle assigned a truncated column variable to the host variable, but the original column value could not be determined. 
	
	You can also use indicator variables in the VALUES and SET clause of an INSERT or UPDATE  statement to assign NULL's to input host variables,
	-1 Oracle will assign a NULL to the column, ignoring the value of the host variable. 
	>=0 Oracle will assign the value of the host variable to the column. 
	
------------------------------------------------
Datatype Equivalencing:
Oracle recognizes two kinds of datatypes:
1) Internal: Internal datatypes specify how Oracle stores column values in database tables.
2) External: specify the formats used to store values in input and output host variables.

**At precompile time, a default Oracle external datatype is assigned to each host variable.

What is Datatype Equivalencing? lets you control the way Oracle interprets the input data and formats the output data. 

The equivalencing can be done as, EXEC SQL VAR <host_var> IS <type_name> [ (<length>) ];
example,
you want to select employee names from the emp table, and then pass them to a routine that expects C-style '\0'-terminated strings

    char emp_name[21];
    EXEC SQL VAR emp_name IS STRING(21);
	
	STRING is an Oracle external datatype specifically designed to interface with C-style strings,
	so When you select a value from the ename column into emp_name, Oracle will automatically '\0'-terminate the value for you. 


	
---------------------------------------------------------
DYNAMIC SQL: i.e. dynamically create entire SQL statements. For DYNAMIC SQL, 
a) statement stored in a string variable can be formed. -->
b) "PREPARE" turns a character string into a SQL statement. -->
c) "EXECUTE" executes that statement.

example,
    char *s = "INSERT INTO emp VALUES(1234, 'jon', 3)";
    EXEC SQL PREPARE q FROM :s;
    EXEC SQL EXECUTE q;
	
Alternatively, PREPARE and EXECUTE may be combined into one statement:
    char *s = "INSERT INTO emp VALUES(1234, 'jon', 3)";
    EXEC SQL EXECUTE IMMEDIATE :s;
------------------------------------------------------------
Oracle Transactions: A transaction is a sequence of SQL statements that Oracle treats as a single unit.
A transaction begins at your first SQL statement and ends when you issue "EXEC SQL COMMIT" or "EXEC SQL ROLLBACK".
----------------------------------------------------------------
ERROR Handling:
After each executable SQL statement, your program can find the status of execution:
1) explicit checking: with SQLCA
2) implicit checking: with WHENEVER statement.

SQLCA (SQL communications area):
a) detect errors and status changes in your program
b) this structure is filled by ORACLE at runtime after every statement execution.
c) To use SQLCA you need to include the header file sqlca.h.

sqlca.h holds the following structure:
		struct sqlca {
			char sqlcaid[8];   -> is initialized to "SQLCA"
			long sqlabc;       -> holds the length, in bytes, of the SQLCA structure. 
			long sqlcode;      -> holds the status code of the most recently executed SQL statement
			struct {
				unsigned short sqlerrml; -> Length of the message text stored in sqlerrmc
				char sqlerrmc[70];  -> Up to 70 characters of the message text for the error code stored in sqlcode.
			} sqlerrm;
			char sqlerrp[8]; -> Reserved for future use
			long sqlerrd[6]; -> Numbers of rows processed
			char sqlwarn[8]; -> used as warning flags
			char sqlext[8];  -> Reserved for future use. 
		};
	
SQLCODE values:
0	No error.
>0	Statement executed but exception detected. This occurs when Oracle cannot find a row that meets your WHERE condition or when a SELECT INTO or FETCH returns no rows.
<0	Oracle did not execute the statement because of an error. When such errors occur, the current transaction should, in most cases, be rolled back.	

NOTE: SQLCA can only accommodate error messages up to 70 characters long in its sqlerrm component. to get longer text,
we use sqlglm() function.The maximum length of an Oracle error message is 512 bytes.

WHENEVER Statement:
allows you to do automatic error checking and handling.
syntax is : EXEC SQL WHENEVER <condition> <action>;

	<condition> can be any of the following:
	SQLWARNING - sqlwarn[0] is set because Oracle returned a warning
	SQLERROR - sqlcode is negative because Oracle returned an error
	NOT FOUND - sqlcode is positive because Oracle could not find a row that meets your WHERE condition, or a SELECT INTO or FETCH returned no rows.

	<action> can be any of the following:
	CONTINUE - Program will try to continue to run with the next statement if possible
	DO - Program transfers control to an error handling function
	GOTO <label> - Program branches to a labeled statement
	STOP - Program exits with an exit() call, and uncommitted work is rolled back
	
	example,
	    EXEC SQL WHENEVER SQLWARNING DO print_warning_msg();
		EXEC SQL WHENEVER NOT FOUND GOTO handle_empty
		
	for (;;) {
		printf("Give student id number : ");
		scanf("%d", &id);
		EXEC SQL WHENEVER NOT FOUND GOTO notfound;
		EXEC SQL SELECT studentname INTO :st_name
				 FROM   student
				 WHERE  studentid = :id;
		printf("Name of student is %s.\n", st_name);
		continue;
	notfound:
		printf("No record exists for id %d!\n", id);
	}
	


	
