Regular expressions: <https://www.python-course.eu/re.php>

Syntax of regular expressions: r"<search string>", example, r"Cat", r"[A-Z]at" etc

the function used to search for a regular expression is search which resides in "re" module

example,
	import re
	x = re.search("cat","A cat and a rat can't be friends.")
	print x
	
	o/p: <_sre.SRE_Match object at 0x7fd4bf238238>
	
	x = re.search("cow","A cat and a rat can't be friends.")
	print x
	
	o/p: None

i.e. If a match has been possible, we get a so-called match object as a result, otherwise the value "None".

better example,
	>>> if re.search("cat","A cat and a rat can't be friends."):
	...     print "Some kind of cat has been found :-)"
	... else:
	...     print "No cat has been found :-("
	... 
	Some kind of cat has been found :-)
	>>> if re.search("cow","A cat and a rat can't be friends."):
	...     print "Cats and Rats and a cow."
	... else:
	...     print "No cow around."
	... 
	No cow around.
	
-----------------
Any character, done via metacharacter ".", 
example
r" .at "
this will search all the strings which,
a) end with "at" example, "rat", "cat", "bat", "eat", "sat".
b) have trailing and preceding spaces i.e. whole words. so it will ignore words like "education", "communicate", "falsification", "ramifications", "cattle".

disadvantage is that it will ignore "at" is strings like ""The cat, called Oscar, climbed on the roof." while the at should have been captured.
----------------
character classes, like any character from A-Z
this is defined by Square brackets, "[" and "]". 
example,
r"M[ae][iy]er"
this will cover four different spellings: Maier, Mayer, Meier, Meyer.

to cover a larger character classes eg, a class of letters between "a" and "e" or between "0" and "5", we use a a metacharacter "-".
example, [a-e] a simplified writing for [abcde] or [0-5] denotes [012345]. 

Another important example, "any lower case or uppercase letter" [A-Za-z]

Question. What character class is described by [-a-z]? 
Answer.   The character "-" and all the characters "a", "b", "c" all the way up to "z".

Uses of caret "^".
[^0-9] denotes the choice "any character but a digit". 
[^abc] means anything but an "a", "b" or "c" 
[a^bc] means an "a", "b", "c" or a "^"

example,
Python script, which finds all the lines of the phone book, which contain a person with the described surname (example , "Neu") and a first name starting with J.

import re
fh = open("simpsons_phone_book.txt")
for line in fh:
    if re.search(r"J.*Neu",line):
        print line.rstrip()
fh.close()

Predefined Character Classes:
character class, which describes a valid word character (i.e. all lower case and uppercase characters, all the digits and the underscore)
corresponding to the following regular expression: r"[a-zA-Z0-9_]"

this regular expression can be replaced by character classes (i.e. special sequences consist of "\\" and a character) as,
\d Matches any decimal digit; equivalent to the set [0-9]. 
\D The complement of \d. It matches any non-digit character; equivalent to the set [^0-9]. 
\s Matches any whitespace character; equivalent to [ \t\n\r\f\v]. 
\S The complement of \s. It matches any non-whitespace character; equiv. to [^ \t\n\r\f\v]. 
\w Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]. With LOCALE, it will match the set [a-zA-Z0-9_] plus characters defined as letters for the current locale. 
\W Matches the complement of \w. 
\b Matches the empty string, but only at the start or end of a word. 
\B Matches the empty string, but not at the start or end of a word. 
\\ Matches a literal backslash. 

More on \b & \B: \b and \B don't match a character. They match empty strings depending on their neighbourhood, i.e. what kind of a character the predecessor and the successor is.
This is exactly opposite of \w or \W which looks for character

example,
text = "catmania thiscat thiscatmaina";
Case 1: At the beginning of each word 
		result = text.replace(/\bcat/g, "ct");
		o/p:
		"ctmania thiscat thiscatmaina"
		
Case 2: At the end of each word
		result = text.replace(/cat\b/g, "ct");
		o/p:
		"catmania thisct thiscatmaina"
		
Case 3: Not in the beginning
		result = text.replace(/\Bcat/g, "ct");
		o/p:
		"catmania thisct thisctmaina"
		
Case 4: Not in the end
		result = text.replace(/cat\B/g, "ct");
		o/p:
		"ctmania thiscat thisctmaina"
		
Case 5: Neither beginning nor end
		result = text.replace(/\Bcat\B/g, "ct");
		o/p:
		"catmania thiscat thisctmaina"

------------------------
Search for a string matching Beginning and End:
1) search string in a "line"
	example 1,
		s1 = "Mayer is a very common Name"
		s2 = "He is called Meyer but he isn't German."
		if re.search(r"M[ae][iy]er", s2):
		 print("match found")
		else:
		 print("match not found")
		 
	o/p: match found

2) search string in beginning "line"	
	example 2,
		s1 = "Mayer is a very common Name"
		s2 = "He is called Meyer but he isn't German."
		if re.search(r"M[ae][iy]er", s2):
		 print("match found")
		else:
		 print("match not found")
		 
	o/p: match not found
	
	example 3
		s1 = "Mayer is a very common Name"
		s2 = "He is called Meyer but he isn't German."
		if re.search(r"M[ae][iy]er", s1):
		 print("match found")
		else:
		 print("match not found")

    o/p: match found
	
	So, "match" can be used in python to check if a line starts with a string.
	
	example 4:
	s4 = s2 + "\n" + s1   #o/p: He is called Meyer but he isn't German.
							   Mayer is a very common Name
							   
	if re.search(r"^M[ae][iy]er",s4): # NOT FOUND
	if re.search(r"^M[ae][iy]er",s4,re.MULTILINE):  #FOUND
	if re.search(r"^M[ae][iy]er",s4,re.M):   #FOUND
	print re.match(r"^M[ae][iy]er", s, re.M): #NOT FOUND. Match only searches beginning of the complete string.
	
3) search string in end "line"
	example,
	print re.search(r"Python\.$","I like Python.")	#FOUND
	print re.search(r"Python\.$","I like Python and Perl.") #NOT FOUND
	print re.search(r"Python\.$","I like Python.\nSome prefer Java or Perl.") #NOT FOUND
	print re.search(r"Python\.$","I like Python.\nSome prefer Java or Perl.", re.M) #FOUND
	
Optional Items: i.e text or characters which may or maynot be present
				example,
				more names ["Mayr", "Meyr", "Meir", "Mair"] plus our old set ["Mayr", "Meyr", "Meir", "Mair"]. so we are dropping one "e" from mayer or meyer.
	 
	This can be accomplished with a question mark ("?").  question mark declares that the preceding character or expression is optional.
    r"M[ae][iy]e?r"      #"e" is optional	
	r"Feb(ruary)? 2011"  #"ruary" is optional. eg, "Feb 2011" or February 2011"


Quantifiers: i.e. repetation factor.
	example1,
	regular expression which matches strings which starts with a sequence of digits followed by a blank and after this arbitrary 	
	characters.
	Solution1: r"^[0-9][0-9] .*"   # i.e. the number [0-9] was replicated 2 times to depict sequence of digits.
	Solution2: r"^[0-9]+ .*"       # i.e. the character/subexpression followed by a "+" sign has to be REPEATED AT LEAST ONE TIME.
	
	example2, 
	regular expression which matches strings which starts with a 4-digits followed by a blank and characters.
	Solution1: r"^[0-9][0-9][0-9][0-9] [A-Za-z]+"
	Solution2: r"^[0-9]{4} [A-Za-z]*"
	
	example3,
	post code which can be 4 or 5 digits long followed by blank and city name which are atleast 3 characters.
	Solution1: r"^[0-9]{4,5} [A-Z][a-z]{3,}"  #this syntax is of format {from,to} i.e. {4,5} is 4 chars to 5 chars.
	
Grouping:
We can group a part of a regular expression by surrounding it with parenthesis i.e.[]
Grouping with parenthesis also creates backreference.
a) match Objects: contains the methods group(), span(), start() and end().
	example1,
	import re
	mo = re.search("[0-9]+", "Customer number: 232454, Date: February 12, 2011")
	mo.group()   #O/p: 232454. group(17,20) will be 
	mo.span()    #O/p: (17,23)
	mo.span()[0] #O/p: 17
	mo.span()[1] #O/p: 23
	mo.start()   #O/p: 17
	mo.end()    #O/p: 23
	
	group can be extended to match substring of the n-th group.syntax: group(n)
	example,
	mo = re.search("([0-9]+).*: (.*)", "Customer number: 232454, Date: February 12, 2011")
	mo.group()     #O/p: '232454, Date: February 12, 2011'
	mo.group(0)    #O/p: '232454, Date: February 12, 2011' i.e. entire group
	mo.group(1)	   #O/p: '232454'
	mo.group(2)    #O/p: 'February 12, 2011'
	mo.group(1,2)  #O/p: ('232454', 'February 12, 2011')


	example2:
	input_file.txt has:
		<composer>Wolfgang Amadeus Mozart</composer>
		<author>Samuel Beckett</author>
		<city>London</city>
		
	code:
	import re
	fh = open("tags.txt")
	for i in fh:
		 res = re.search(r"<([a-z]+)>(.*)</\1>",i)  # "\1" is backreference for group(1)  
		 print res.group(1) + ": " + res.group(2)
	
	o/p:
	composer: Wolfgang Amadeus Mozart
	author: Samuel Beckett
	city: London

	NOTE: If there are more than one pair of parenthesis (round brackets) inside the expression, the backreferences are numbered \1, \2, \3, in the order of 
	      the pairs of parenthesis.


	example3:
	import re
	#
	l = ["555-8396 Neu, Allison", 
		 "Burns, C. Montgomery", 
		 "555-5299 Putz, Lionel",
		 "555-7334 Simpson, Homer Jay"]
	#
	for i in l:
		res = re.search(r"([0-9-]*)\s*([A-Za-z]+),\s+(.*)", i)
		print res.group(3) + " " + res.group(2) + " " + res.group(1)
		
	o/p:
	Allison Neu 555-8396
	C. Montgomery Burns 
	Lionel Putz 555-5299
	Homer Jay Simpson 555-7334
 
----------------------------------------------
Finding all the Matched SubStrings:
Syntax is, re.findall(pattern, string[, flags])

example 1,
    import re
	t="A fat cat doesn't eat oat but a rat eats bats."
	mo = re.findall("[force]at", t)
	print mo

	o/p:
	['fat', 'cat', 'eat', 'oat', 'rat', 'eat']

Note:
1) The string is scanned left-to-right.
2) returns all non-overlapping matches of pattern in string.
3) Returns list of strings.

example 2,
	import re
	items = re.findall("[0-9]+.*: .*", "Customer number: 232454, Date: February 12, 2011")
	print items  # O/p: ['232454, Date: February 12, 2011'] i.e. 1 item in the list
	items = re.findall("([0-9]+).*: (.*)", "Customer number: 232454, Date: February 12, 2011")
	print items  # O/p: [('232454', 'February 12, 2011')]   i.e. 2 items in the list as 2 groups have been declared.
	
------------------------------------------------
How to find choice between several regular expression:
This can be done by using a "|" operator between the character classes.
example1,
	import re
	str1 = "The destination is London!"
	mo = re.search(r"destination.*(London|Paris|Zurich|Strasbourg)",str)
	if mo: print mo.group()

	o/p: destination is London
	
example2,
	r"(^To:|^From:) (Guido|van Rossum)"
	
-------------------------------------------------
Compiling Regular Expressions: 
Compiling is done to use the same regexp more than once in a script. compile returns a regex object, which can be used later for searching and replacing.
syntax is : re.compile(pattern[, flags])

NOTE: Compiled regular objects usually are not saving much time, because Python internally compiles AND CACHES regexes whenever you use them with re.search() or re.match()

example,
	import re
	regex = r"[A-z]{1,2}[0-9R][0-9A-Z]? [0-9][ABD-HJLNP-UW-Z]{2}"
	address = "BBC News Centre, London, W12 7RJ"
	compiled_re = re.compile(regex)
	res = compiled_re.search(address)
	print res
-------------------------------------------------
Regular expression split:
The string method split() is the right tool in many cases, but what, if you want e.g. to get the bare words of a text, i.e. without any special characters and whitespaces. If we want this, we have to use the split function from the re module.

example1,
	import re
	metamorphoses = "OF bodies chang'd to various forms, I sing: Ye Gods, from whom these miracles did spring, Inspire my numbers with coelestial heat;"
	re.split("\W+",metamorphoses)

o/p:
['OF', 'bodies', 'chang', 'd', 'to', 'various', 'forms', 'I', 'sing', 'Ye', 'Gods', 'from', 'whom', 'these', 'miracles', 'did', 'spring', 'Inspire', 'my', 'numbers', 'with', 'coelestial', 'heat', '']

example2,
	import re
	lines = ["surname: Obama, prename: Barack, profession: president", "surname: Merkel, prename: Angela, profession: chancellor"]
	for line in lines:
		re.split(",* *\w*: ", line)
		
o/p: 
['', 'Obama', 'Barack', 'president']
['', 'Merkel', 'Angela', 'chancellor']

example3,
	import re
	lines = ["surname: Obama, prename: Barack, profession: president", "surname: Merkel, prename: Angela, profession: chancellor"]
	for line in lines:
		re.split(",* *\w*: ", line)[1:]
	
o/p:
['Obama', 'Barack', 'president']
['Merkel', 'Angela', 'chancellor']

---------------------------------------------------
Search and Replace:
	re.sub(regex, replacement, subject)
	
example,
	import re
	str = "yes I said yes I will Yes."
	res = re.sub("[yY]es","no", str)
	print res

	O/p: no I said no I will no.
	

-----------------------------------------------------
MapReduce take-2 : https://www.python-course.eu/lambda.php

	

 



 