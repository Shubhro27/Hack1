Pandas:
shortform for "Panel Data System" is built on top of NumPy and SciPy

Pandas has,
1) a tabular data structure that can hold both homogenous and heterogenous data.
2) Very good indexing capabilities that makes data alignment and merging easy.
3) Good time series functionality. No need to use different data structures for time series and cross sectional data. Allows for both ordered and unordered time-series data.
4) A host of statistical functions developed around NumPy and pandas that makes a researcher’s task easy and fast.
5) Programming is lot simpler and faster.
6) Easily handles data manipulation and cleaning.
7) Easy to expand and shorten data sets. Comprehensive merging, joins, and group by functionality to join multiple data sets.

In order to be able to use Pandas and NumPy, first import it using import statement
import pandas as pd                         # This will import pandas into your workspace
import numpy as np                          # We will be using numpy functions so import numpy

There are 2 key components in Panda:
1) Series : Series is a 1-D array like object. pandas attaches a label to each of the values. If the labels are not provided by the programmer, 
			then pandas assigns labels ( 0 for first element, 1 for second element and so on).
			A benefit of assigning labels to data values is that it becomes easier to perform manipulations on the dataset as the whole dataset 
			becomes more of a dictionary where each value is associated with a label.
			
			example, 
			import pandas as pd
			s = pd.Series((1,2,3,4,5)) //series object for tuple
			s1 = pd.Series(list('abcdef')) //series object for list.
			print s
			print s.values
			print s.index    //default index is 0 : N-1
			print s1
			print s1.values
			print s1.index
			
			o/p:
			print s will give:
			0	1
			1	2
			2	3
			3	4
			4	5
			
			print s.index will give: 0 1 2 3 4 
			print s.values will give : 1 2 3 4 5
			
			Print s1 will give:
			0	a
			1	b
			2	c
			3	d
			4	e
			5	f
			
			print s1.index will give: 0 1 2 3 4 5
			print s1.values will give: a b c d e f
			
			
		** NOTE: details mentioned later in this learning doc	
					 
2) Dataframe: 2-D tabular data structure with integrated indexing. Supports both homogeneous and heterogeneous columns.
			example,
			import pandas as pd
			pop_data = {'FL':{2010:18.8,2011:19.1},'GA':{2008:9.7,2010:9.7,2011:9.8}}
			pop = pd.DataFrame(pop_data)
			print pop
			
			o/p:
					FL		GA
			2008	NaN		9.7
			2010	18.8	9.7
			2011	19.1	9.8

-------------------
Lambda Functions: i.e. functions without a name which are used as soon as they have been created.
				Syntax: lambda argument_list: expression (usually functions like filter(),map(),reduce())
						where,
						argument_list: comma separated arguments.
						expression: arithmetic expression using arguments.
						
						
				example,
				f = lambda x,y: x+y
				print (f(1,1))
				
				o/p:
				2
				
what is map() function?
map function syntax is - map(func,sequence) where func -> name of function and sequence is a list, array etc
map function applies to all elements in the sequence i.e. the function will be applied on each element.
map function returns a new list of elements changed by func

example (function usage of map vs lambda usage of map),
def far(T):
 return((float(9)/5)*T + 32)
 
def celsius(T):
 return((float(5)/9)*(T - 32)
 
temp = (36.5,37,37.5,39)
f = map(far,temp)
c = map (celsius,f)

with lambda,
celsius = (36.5,37,37.5,39)
far = map(lambda x:(float(9)/5)*x+32,celsius)
C = map( lambda x:(float(5)/9)*(x-32),far)

------------------------------------------------
Linspace:
provides result of the formula = (Max - Initial)/[number of elements - 1]
example,
	array(np.linspace(2,4,9))

o/p:
[2 2.25 2.75 3.0 3.25 3.50 3.75 4.0]

-------------------------------------------------
Pandas Series (revisited): definition already present.

example 1,
	import pandas as pd
	import numpy as np
	series1 = pd.Series([10,20,30,40])   #NOTE: Series keyword is case sensitive. "series" will error out.
	print (series1)
	print (series1.values)   #will give the data type object of the Series and the values
	print (series1.index)    #will give the index data type (usually Int64) and list of index values and data type.
	print ("\n")
	series2 = pd.Series([1,2,3,4,5],index = [10,20,30,40,50])  #creating custom indexes
	print (series2)
	print (series2.values)
	print (series2.index) 

o/p:
	0    10
	1    20
	2    30
	3    40
	#
	dtype: int64
	[10 20 30 40]
	#
	Int64Index([0, 1, 2, 3], dtype='int64')

	10    1
	20    2
	30    3
	40    4
	50    5
	#
	dtype: int64
	[1 2 3 4 5]
	#
	Int64Index([10, 20, 30, 40, 50], dtype='int64')

example 2, Series can accept heterogeneous datatypes. In case a series has heterogenous items, dtype: object
	series3 = pd.Series([1,2,3,"four",5],index = [10,20,30,40,50])
	print (series3)
	print (series3.values)
	print (series3.index)

	o/p:
	10       1
	20       2
	30       3
	40    four
	50       5
	#
	dtype: object
	[1 2 3 'four' 5]
	#
	Int64Index([10, 20, 30, 40, 50], dtype='int64')

example 3, string index and heterogeneous index,
	series4 = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])
	print (series4)
	print (series4.values)
	print (series4.index)
	print ("\n")
	#
	series5 = pd.Series([1,2,3,4,5],index = ['one',2,'three','four',5])
	print (series5)
	print (series5.values)
	print (series5.index)	

	o/p:
	a    1
	b    2
	c    3
	d    4
	e    5
	dtype: int64
	[1 2 3 4 5]
	Index([u'a', u'b', u'c', u'd', u'e'], dtype='object')
	#
	one      1
	2        2
	three    3
	four     4
	5        5
	dtype: int64
	[1 2 3 4 5]
	Index([u'one', 2, u'three', u'four', 5], dtype='object')	


Accessing specific elements in a series: this can be done using the same way as numpy.
example,
	series3 = pd.Series([1,2,3,"four",5],index = [10,20,30,40,50])
	print (series3[[10,40]])
	print (series3[[10:40]])   //THIS WILL ERROR. SyntaxError: invalid syntax
	series5 = pd.Series([1,2,3,4,5],index = ['one',2,'three','four',5])
	print (series5[2])
	print (series5['three'])
    print (series5['two'])  //THIS WILL ERROR. KeyError: 'two'
	print (series3[60])     //THIS WILL ERROR as 60 is not listed in index.
	
	o/p:
	#series3
	10       1
	20       2
	30       3
	40    four
	50       5	

	10       1
	40    four
	dtype: object

	#series5
	one      1
	2        2
	three    3
	four     4
	5        5

	2
	9
	
However, if we give a [[]], the keyError is bypassed and o/p becomes NaN
	example,
	series3 = pd.Series([1,2,3,"four",5],index = [10,20,30,40,50])
	print (series3[[60]])
	print (series3['two'])
	print (series3[['two',60,45]]) 
	
	O/p:
	60    NaN
	#
	two   NaN
	#
	two    NaN
	60     NaN
	45     NaN
	
to show the elements for an index range. ex, show all elements between 2 to 4 index values.
example,
	series8 = pd.Series([1,2,3,4,5])
	print (series8.ix[2:4])
	print (series8.ix[2:6])   //If index is out of bounds, elements are displayed only till the maximum index value.

	o/p:
	2    3
	3    4
	4    5
	dtype: int64
	
Arithmetic operations on each element in a series.
example,
	series6 = pd.Series([1,2,3,4,5])
	print (series6 + 10)
	print (series6 ** 2)
	print (np.sqrt(series6))
	series7 = series6 + 10
	print (series7)   #Assignment to a different series. same result as (series6 + 10).

	O/p:
	0    11
	1    12
	2    13
	3    14
	4    15
	dtype: int64
	0     1
	1     4
	2     9
	3    16
	4    25
	dtype: int64
	0    1.000000
	1    1.414214
	2    1.732051
	3    2.000000
	4    2.236068
	dtype: float64
	
Filtering elements of a series.
example,
		print (series7[series7 > 11])
		print (series2[[series2>30]]) #i.e. [[]], will error with too many indices.
	
	o/p:
	1    12
	2    13
	3    14
	4    15
	dtype: int64
	
If you have a dictionary, you can create a Series data structure from that dictionary,
example,
	years = [91, 90, 92, 93, 94, 95, 96, 97]
	f1 = {90:8, 91:9, 92:7, 93:8, 94:9, 95:11, 96:13}
	firm1 = pd.Series(f1,index=years)                     # Extra element in VALUE not an issue. The extra element is NaN
	print(firm1)
	f2 = {90:14,92:9, 93:13, 94:5}
	firm2 = pd.Series(f2,index=years)
	print(firm2)
	print (pd.isnull(firm2))  							  # isnull() function to find out if there are any missing values in the data structure.
	print (~pd.isnull(firm2))                             # "~" is NOT Operator. gives opposite of previous statement.
	
	o/p:
	91     9
	90     8
	92     7
	93     8
	94     9
	95    11
	96    13
	97   NaN
	dtype: float64
	#
	91   NaN
	90    14
	92     9
	93    13
	94     5
	95   NaN
	96   NaN
	97   NaN
	dtype: float64
	#
	91     True
	90    False
	92    False
	93    False
	94    False
	95     True
	96     True
	97     True
	dtype: bool
	
	NOTE: NaN stands for missing or NA values in pandas. Make use of isnull() function to find out if there are any missing values in the data structure.
	
	
If we are operating on 2 different series, we do not have to worry about data alignment. Pandas takes care of that.
example, calculate the sum of common words in combined files
	dict1 = {'finance': 10, 'earning': 5, 'debt':8}
	dict2 = {'finance' : 8, 'compensation':4, 'earning': 9}
	count1 = pd.Series(dict1)
	count2 = pd.Series(dict2)
	print (count1)
	print (count2)
	print (count1 + count2) #
	
	o/p:
	debt        8
	earning     5
	finance    10
	dtype: int64
	#
	compensation    4
	earning         9
	finance         8
	dtype: int64
	#
	compensation     NaN
	debt             NaN
	earning         14.0
	finance         18.0
	
-----------------------------------------------------------------------------
Data Frame (revisited):
is a tabular data structure in which data is laid out in rows and column format (similar to a CSV and SQL file),
DF is logical extension of Series data structures. 
In contrast to Series, where there is one index, a DataFrame object has one index for column and one index for rows. 
This allows flexibility in accessing and manipulating data.

example,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	print(data) 	

	O/p: # each key forms a column and each row is automatically indexed from 0-n
		company				price	ticker
	0	American Express	95		AXP
	1	Cisco				25		CSCO
	2	Walt Disney			85		DIS
	3	Microsoft			41		MSFT
	4	Walmart				78		WMT

Note: all the arrays in a DF should be of the same size,
example,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney']})  /#i.e. company has only 3 values
	print(data)
						 
	O/p:
	ValueError: arrays must all be same length

to print data for a specific key,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	print(data['company'])
	print(data.company)  //same result as above  
	
	o/p:
	0    American Express
	1               Cisco
	2         Walt Disney
	3           Microsoft
	4             Walmart
	Name: company, dtype: object
	
to print a row corresponding to an index,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	print (data.ix[2])       # Print the row corresponding to the given Index
	print (data.ix[2:4])     #range of indices
	
	o/p:
	company    Walt Disney
	price               85
	ticker             DIS
	Name: 2, dtype: object
	
		   company  price ticker
	2  Walt Disney     85    DIS
	3    Microsoft     41   MSFT
	4      Walmart     78    WMT
	
filtering DF based on "key"/"columns":
example,
	data.ix[data.ticker=='DIS']            # Print the row corresponding to the ticker that is 'DIS'
	print(data)

	o/p:
		company		price	ticker
	2	Walt Disney	85		DIS

adding a new column to a DF,
example,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	data['Year'] = 2014                    # Add additional column Year. Populate value of 2014 in all the rows.
	print(data)
	data['pricesquared'] = data.price**2      # Square all the prices and add another column 'pricesquared'.
	print(data)
	del data['pricesquared']                  # Delete column 'pricesquared'
	print(data)
	data['pricesquared'] = np.NaN             # Create column 'pricesquared' with NaN values
	print(data)
	data['sequence'] = np.arange(2014,2024,2) # Add column 'sequence'												
	print(data)
	
O/p:
	company				price	ticker	Year
0	American Express	95		AXP		2014
1	Cisco				25		CSCO	2014
2	Walt Disney			85		DIS		2014
3	Microsoft			41		MSFT	2014
4	Walmart				78		WMT		2014
#
	company				price	ticker	Year	pricesquared
0	American Express	95		AXP		2014	9025
1	Cisco				25		CSCO	2014	625
2	Walt Disney			85		DIS		2014	7225
3	Microsoft			41		MSFT	2014	1681
4	Walmart				78		WMT		2014	6084
#
	company				price	ticker	Year
0	American Express	95		AXP		2014
1	Cisco				25		CSCO	2014
2	Walt Disney			85		DIS		2014
3	Microsoft			41		MSFT	2014
4	Walmart				78		WMT		2014
#
	company				price	ticker	Year	pricesquared
0	American Express	95		AXP		2014	NaN
1	Cisco				25		CSCO	2014	NaN
2	Walt Disney			85		DIS		2014	NaN
3	Microsoft			41		MSFT	2014	NaN
4	Walmart				78		WMT		2014	NaN
#
	company				price	ticker	Year	pricesquared	sequence
0	American Express	95		AXP		2014	NaN				2014
1	Cisco				25		CSCO	2014	NaN				2016
2	Walt Disney			85		DIS		2014	NaN				2018
3	Microsoft			41		MSFT	2014	NaN				2020
4	Walmart				78		WMT		2014	NaN				2022


Using Numpy functions inside DataFrame Objects:
example,
	import pandas as pd
	import numpy as np
	# Create array of 3*3 dimensionality using standard normally distributed random vales
	dataframe = pd.DataFrame(np.random.randn(3,3),columns=['one','two','three'])  
	print(dataframe)
	print(np.abs(dataframe))                   # Absolute value
	f = lambda x:x.max()-x.min()               # lambda function to get range i.e. max - min.
	print (abs(dataframe).apply(f))            # applies to column (BY-DEFAULT)
	abs(dataframe).apply(f,axis=1)             #axis=1, applies to row
	
	
	o/p:
		one			two			three
	0	-0.057379	0.244387	0.128660
	1	0.342184	1.080002	-0.528302
	2	0.370405	-0.319412	1.427701
	#
		one			two			three
	0	0.057379	0.244387	0.128660
	1	0.342184	1.080002	0.528302
	2	0.370405	0.319412	1.427701
	# column range
	one      0.313026
	two      0.835614
	three    1.299041
	dtype: float64
	#row range
	0    0.187008
	1    0.737818
	2    1.108289
	dtype: float64
	
example-2:
	print(dataframe)
	dataframe.sum()                          # Column wise sum
	dataframe.sum(axis=1)                    # Row wise sum
	dataframe.cumsum()                 		 # Get cumulative sum for columns 
	
o/p:
#column-wise
one      0.655210
two      1.004977
three    1.028059
dtype: float64
#row-wise
0    0.315668
1    0.893883
2    1.478694
dtype: float64
#cumlative
        one       two     three
0       0.043830  1.328110  0.739642
1       0.040941  1.518764  2.111642
2      -0.331633  1.103796  3.745047
i.e. each column value is added to the next column value. if dataframe.cumsum(axis=1), the sum of consecutive rows. 

	
function to create a series having mean, max and min of a set of DF rows using numpy functions.
example,
	def f(x):
		return pd.Series([np.mean(x), x.max(), x.min()], index=['mean','max','min'])
	print(dataframe)
	print(dataframe.apply(f,axis=1))
	
o/p:
	one       two     three
0 -0.057379  0.244387  0.128660
1  0.342184  1.080002 -0.528302
2  0.370405 -0.319412  1.427701
#
	mean		max			min
0	0.105223	0.244387	-0.057379
1	0.297961	1.080002	-0.528302
2	0.492898	1.427701	-0.319412
	
describe the characteristics of a dataframe,
example, (when the data frame contains numbers)
	dataframe = pd.DataFrame(np.random.randn(3,3),columns=['one','two','three']) 
	dataframe.describe()
	
	o/p:
				one       two     three
	count  3.000000  3.000000  3.000000
	mean   0.170356  1.069239 -0.593476
	std    0.994400  0.551264  0.298080
	min   -0.975123  0.432745 -0.849494
	25%   -0.150436  0.906642 -0.757096
	50%    0.674251  1.380539 -0.664698
	75%    0.743096  1.387486 -0.465467
	max    0.811941  1.394433 -0.266237
	
example, (when the dataframe is combination of string and number columns, describe will only aggregate the numeric fields in the DF
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	
	data['Year'] = [2014] 
	print(data)
	
	o/p:
			  price
	count   5.00000
	mean   64.80000
	std    30.18609
	min    25.00000
	25%    41.00000
	50%    78.00000
	75%    85.00000
	max    95.00000

			  price  Year
	count   5.00000     5
	mean   64.80000  2014
	std    30.18609     0
	min    25.00000  2014
	25%    41.00000  2014
	50%    78.00000  2014
	75%    85.00000  2014
	max    95.00000  2014

example, (when the data frame contains ONLY string),
	data = pd.DataFrame({'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	print(data.describe())
	
	o/p:
				company ticker
	count             5      5
	unique            5      5
	top     Walt Disney    DIS
	freq              1      1

To conclude,
Describe will give - count, mean, std, min, max FOR NUMBERS
					 count, unique, top, freq FOR STRINGS
					 
					 
-----------------------------------------------------------------------------------------------------------
Pandas for handling missing data:

1) how to create a dataFrame from a set of series, INITIALIZE to NaN and then populate it with series data as columns.

	example,
		import numpy as np
		import pandas as pd
		years = [90, 91, 92, 93, 94, 95]
		f1 = {90:8, 91:9, 92:7, 93:8, 94:9, 95:11}
		firm1 = pd.Series(f1,index=years)
		print firm1print("\n")
		f2 = {90:14,92:9, 93:13, 94:5}
		firm2 = pd.Series(f2,index=years)
		print firm2
		print("\n")
		f3 = {93:10, 94:12, 95: 13}
		firm3 = pd.Series(f3,index=years)
		print firm3print("\n")
		df3 = pd.DataFrame(columns=['Firm1','Firm2','Firm3'],index=years)
		print df3
		print("\n")
		df3.Firm1 = firm1
		df3.Firm2 = firm2
		df3.Firm3 = firm3
		print df3
		
	o/p:
	90     8
	91     9
	92     7
	93     8
	94     9
	95    11
	dtype: int64
	90    14
	91   NaN
	92     9
	93    13
	94     5
	95   NaN
	dtype: float64
	90   NaN
	91   NaN
	92   NaN
	93    10
	94    12
	95    13
	dtype: float64
		 Firm1 Firm2 Firm
	390  NaN   NaN   NaN
	91   NaN   NaN   NaN
	92   NaN   NaN   NaN
	93   NaN   NaN   NaN
	94   NaN   NaN   NaN
	95   NaN   NaN   NaN

		 Firm1  Firm2  Firm3
	90      8     14    NaN
	91      9    NaN    NaN
	92      7      9    NaN
	93      8     13     10
	94      9      5     12
	95     11    NaN     13
	
2) drop NaN values from a series or DataFrame.
	1) delete the entire row from series or DF which has NaN
		years = [90, 91, 92, 93, 94, 95]
		f2 = {90:14,92:9, 93:13, 94:5}
		firm2 = pd.Series(f2,index=years)
		print(firm2)
		nadeleted = firm2.dropna()
		print(nadeleted)
		cleandf3 = df3.dropna(axis=1)          # DF3 row created above. REMOVES COLUMNS having even 1 NaN value.
		#cleandf3 = df3.dropna(axis=0)         # df3.dropna() will REMOVE ROWS having even 1 NaN value.
		print(cleandf3)
		
		o/p:
		90    14
		91   NaN
		92     9
		93    13
		94     5
		95   NaN
		dtype: float64
		#91 and 95th rows are deleted
		90    14
		92     9
		93    13
		94     5
		dtype: float64
		#DF3
			 Firm1  Firm2  Firm3
		90      8     14    NaN
		91      9    NaN    NaN
		92      7      9    NaN
		93      8     13     10
		94      9      5     12
		95     11    NaN     13
		#df3.dropna(axis=1) 
			Firm1
		90      8
		91      9
		92      7
		93      8
		94      9
		95     11
		#df3.dropna(axis=0)
			Firm1  Firm2  Firm3
		93      8     13     10
		94      9      5     12
		
	3) drop a row only if ALL the values in the row is NaN. ex, clean2 = df3.dropna(how='all')

	4) Define threshold of NaN i.e. number of NaN for a row/column is > threshhold.
			thresholddf1 = df3.dropna(axis=1,thresh=2)    # Define threshold. In this case column having >= 2 NaN, drop the column
			thresholddf2 = df3.dropna(axis=0,thresh=2)    # Define threshold. In this case row having >= 2 NaN, drop the row
			
	5) fill the NaN with another value.
		example,
		fillna1 = df3.fillna(0)      # Fill all NaN values with 0
		print(fillna1)
		fillna2 = df3.fillna({'Firm1':8, 'Firm2': 10, 'Firm3':14})	# We can specify what value should be replaced
		print(fillna2)				
		
	o/p:
				 Firm1  Firm2  Firm3
			90      8     14    NaN
			91      9    NaN    NaN
			92      7      9    NaN
			93      8     13     10
			94      9      5     12
			95     11    NaN     13
			##### replaced with ZERO
				Firm1  Firm2  Firm3
			90      8     14      0
			91      9      0      0
			92      7      9      0
			93      8     13     10
			94      9      5     12
			95     11      0     13
			##### replace with different values
				Firm1  Firm2  Firm3
			90      8     14     14
			91      9     10     14
			92      7      9     14
			93      8     13     10
			94      9      5     12
			95     11     10     13
			
		example 2,
		#Forward fill and backward fill
		fillna3 = df3.fillna(method='ffill')
		print(fillna3)
		fillna4 = df3.fillna(method='bfill')
		print(fillna4)
		
	o/p:
				 Firm1  Firm2  Firm3
			90      8     14    NaN
			91      9    NaN    NaN
			92      7      9    NaN
			93      8     13     10
			94      9      5     12
			95     11    NaN     13
			#####forward fill
				Firm1  Firm2  Firm3
			90      8     14    NaN
			91      9     14    NaN
			92      7      9    NaN
			93      8     13     10
			94      9      5     12
			95     11      5     13
			#####backward fill
				Firm1  Firm2  Firm3
			90      8     14     10
			91      9      9     10
			92      7      9     10
			93      8     13     10
			94      9      5     12
			95     11    NaN     13
		
	

