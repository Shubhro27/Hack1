Pandas:
shortform for "Panel Data System" is built on top of NumPy and SciPy

Pandas has,
1) a tabular data structure that can hold both homogenous and heterogenous data.
2) Very good indexing capabilities that makes data alignment and merging easy.
3) Good time series functionality. No need to use different data structures for time series and cross sectional data. Allows for both ordered and unordered time-series data.
4) A host of statistical functions developed around NumPy and pandas that makes a researcher’s task easy and fast.
5) Programming is lot simpler and faster.
6) Easily handles data manipulation and cleaning.
7) Easy to expand and shorten data sets. Comprehensive merging, joins, and group by functionality to join multiple data sets.

In order to be able to use Pandas and NumPy, first import it using import statement
import pandas as pd                         # This will import pandas into your workspace
import numpy as np                          # We will be using numpy functions so import numpy

There are 2 key components in Panda:
1) Series : Series is a 1-D array like object. pandas attaches a label to each of the values. If the labels are not provided by the programmer, 
			then pandas assigns labels ( 0 for first element, 1 for second element and so on).
			A benefit of assigning labels to data values is that it becomes easier to perform manipulations on the dataset as the whole dataset 
			becomes more of a dictionary where each value is associated with a label.
			
			example, 
			import pandas as pd
			s = pd.Series((1,2,3,4,5)) //series object for tuple
			s1 = pd.Series(list('abcdef')) //series object for list.
			print s
			print s.values
			print s.index    //default index is 0 : N-1
			print s1
			print s1.values
			print s1.index
			
			o/p:
			print s will give:
			0	1
			1	2
			2	3
			3	4
			4	5
			
			print s.index will give: 0 1 2 3 4 
			print s.values will give : 1 2 3 4 5
			
			Print s1 will give:
			0	a
			1	b
			2	c
			3	d
			4	e
			5	f
			
			print s1.index will give: 0 1 2 3 4 5
			print s1.values will give: a b c d e f
			
			
		** NOTE: details mentioned later in this learning doc	
					 
2) Dataframe: 2-D tabular data structure with integrated indexing. Supports both homogeneous and heterogeneous columns.
			example,
			import pandas as pd
			pop_data = {'FL':{2010:18.8,2011:19.1},'GA':{2008:9.7,2010:9.7,2011:9.8}}
			pop = pd.DataFrame(pop_data)
			print pop
			
			o/p:
					FL		GA
			2008	NaN		9.7
			2010	18.8	9.7
			2011	19.1	9.8

-------------------
Lambda Functions: i.e. functions without a name which are used as soon as they have been created.
				Syntax: lambda argument_list: expression (usually functions like filter(),map(),reduce())
						where,
						argument_list: comma separated arguments.
						expression: arithmetic expression using arguments.
						
						
				example,
				f = lambda x,y: x+y
				print (f(1,1))
				
				o/p:
				2
				
what is map() function?
map function syntax is - map(func,sequence) where func -> name of function and sequence is a list, array etc
map function applies to all elements in the sequence i.e. the function will be applied on each element.
map function returns a new list of elements changed by func

example (function usage of map vs lambda usage of map),
def far(T):
 return((float(9)/5)*T + 32)
 
def celsius(T):
 return((float(5)/9)*(T - 32)
 
temp = (36.5,37,37.5,39)
f = map(far,temp)
c = map (celsius,f)

with lambda,
celsius = (36.5,37,37.5,39)
far = map(lambda x:(float(9)/5)*x+32,celsius)
C = map( lambda x:(float(5)/9)*(x-32),far)

------------------------------------------------
Linspace:
provides result of the formula = (Max - Initial)/[number of elements - 1]
example,
	array(np.linspace(2,4,9))

o/p:
[2 2.25 2.75 3.0 3.25 3.50 3.75 4.0]

-------------------------------------------------
Pandas Series (revisited): definition already present.

example 1,
	import pandas as pd
	import numpy as np
	series1 = pd.Series([10,20,30,40])   #NOTE: Series keyword is case sensitive. "series" will error out.
	print (series1)
	print (series1.values)   #will give the data type object of the Series and the values
	print (series1.index)    #will give the index data type (usually Int64) and list of index values and data type.
	print ("\n")
	series2 = pd.Series([1,2,3,4,5],index = [10,20,30,40,50])  #creating custom indexes
	print (series2)
	print (series2.values)
	print (series2.index) 

o/p:
	0    10
	1    20
	2    30
	3    40
	#
	dtype: int64
	[10 20 30 40]
	#
	Int64Index([0, 1, 2, 3], dtype='int64')

	10    1
	20    2
	30    3
	40    4
	50    5
	#
	dtype: int64
	[1 2 3 4 5]
	#
	Int64Index([10, 20, 30, 40, 50], dtype='int64')

example 2, Series can accept heterogeneous datatypes. In case a series has heterogenous items, dtype: object
	series3 = pd.Series([1,2,3,"four",5],index = [10,20,30,40,50])
	print (series3)
	print (series3.values)
	print (series3.index)

	o/p:
	10       1
	20       2
	30       3
	40    four
	50       5
	#
	dtype: object
	[1 2 3 'four' 5]
	#
	Int64Index([10, 20, 30, 40, 50], dtype='int64')

example 3, string index and heterogeneous index,
	series4 = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])
	print (series4)
	print (series4.values)
	print (series4.index)
	print ("\n")
	#
	series5 = pd.Series([1,2,3,4,5],index = ['one',2,'three','four',5])
	print (series5)
	print (series5.values)
	print (series5.index)	

	o/p:
	a    1
	b    2
	c    3
	d    4
	e    5
	dtype: int64
	[1 2 3 4 5]
	Index([u'a', u'b', u'c', u'd', u'e'], dtype='object')
	#
	one      1
	2        2
	three    3
	four     4
	5        5
	dtype: int64
	[1 2 3 4 5]
	Index([u'one', 2, u'three', u'four', 5], dtype='object')	


Accessing specific elements in a series: this can be done using the same way as numpy.
example,
	series3 = pd.Series([1,2,3,"four",5],index = [10,20,30,40,50])
	print (series3[[10,40]])
	print (series3[[10:40]])   //THIS WILL ERROR. SyntaxError: invalid syntax
	series5 = pd.Series([1,2,3,4,5],index = ['one',2,'three','four',5])
	print (series5[2])
	print (series5['three'])
    print (series5['two'])  //THIS WILL ERROR. KeyError: 'two'
	print (series3[60])     //THIS WILL ERROR as 60 is not listed in index.
	
	o/p:
	#series3
	10       1
	20       2
	30       3
	40    four
	50       5	

	10       1
	40    four
	dtype: object

	#series5
	one      1
	2        2
	three    3
	four     4
	5        5

	2
	9
	
However, if we give a [[]], the keyError is bypassed and o/p becomes NaN
	example,
	series3 = pd.Series([1,2,3,"four",5],index = [10,20,30,40,50])
	print (series3[[60]])
	print (series3['two'])
	print (series3[['two',60,45]]) 
	
	O/p:
	60    NaN
	#
	two   NaN
	#
	two    NaN
	60     NaN
	45     NaN
	
Arithmetic operations on each element in a series.
example,
	series6 = pd.Series([1,2,3,4,5])
	print (series6 + 10)
	print (series6 ** 2)
	print (np.sqrt(series6))
	series7 = series6 + 10
	print (series7)   #Assignment to a different series. same result as (series6 + 10).

	O/p:
	0    11
	1    12
	2    13
	3    14
	4    15
	dtype: int64
	0     1
	1     4
	2     9
	3    16
	4    25
	dtype: int64
	0    1.000000
	1    1.414214
	2    1.732051
	3    2.000000
	4    2.236068
	dtype: float64
	
Filtering elements of a series.
example,
		print (series7[series7 > 11])
		print (series2[[series2>30]]) #i.e. [[]], will error with too many indices.
	
	o/p:
	1    12
	2    13
	3    14
	4    15
	dtype: int64
	
If you have a dictionary, you can create a Series data structure from that dictionary,
example,
	years = [91, 90, 92, 93, 94, 95, 96, 97]
	f1 = {90:8, 91:9, 92:7, 93:8, 94:9, 95:11, 96:13}
	firm1 = pd.Series(f1,index=years)                     # Extra element in VALUE not an issue. The extra element is NaN
	print(firm1)
	f2 = {90:14,92:9, 93:13, 94:5}
	firm2 = pd.Series(f2,index=years)
	print(firm2)
	print (pd.isnull(firm2))  							  # isnull() function to find out if there are any missing values in the data structure.
	print (~pd.isnull(firm2))                             # "~" is NOT Operator. gives opposite of previous statement.
	
	o/p:
	91     9
	90     8
	92     7
	93     8
	94     9
	95    11
	96    13
	97   NaN
	dtype: float64
	#
	91   NaN
	90    14
	92     9
	93    13
	94     5
	95   NaN
	96   NaN
	97   NaN
	dtype: float64
	#
	91     True
	90    False
	92    False
	93    False
	94    False
	95     True
	96     True
	97     True
	dtype: bool
	
	NOTE: NaN stands for missing or NA values in pandas. Make use of isnull() function to find out if there are any missing values in the data structure.
	
	
If we are operating on 2 different series, we do not have to worry about data alignment. Pandas takes care of that.
example, calculate the sum of common words in combined files
	dict1 = {'finance': 10, 'earning': 5, 'debt':8}
	dict2 = {'finance' : 8, 'compensation':4, 'earning': 9}
	count1 = pd.Series(dict1)
	count2 = pd.Series(dict2)
	print (count1)
	print (count2)
	print (count1 + count2) #
	
	o/p:
	debt        8
	earning     5
	finance    10
	dtype: int64
	#
	compensation    4
	earning         9
	finance         8
	dtype: int64
	#
	compensation     NaN
	debt             NaN
	earning         14.0
	finance         18.0
	
-----------------------------------------------------------------------------
Data Frame (revisited):
is a tabular data structure in which data is laid out in rows and column format (similar to a CSV and SQL file),
DF is logical extension of Series data structures. 
In contrast to Series, where there is one index, a DataFrame object has one index for column and one index for rows. 
This allows flexibility in accessing and manipulating data.

example,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	print(data) 	

	O/p: # each key forms a column and each row is automatically indexed from 0-n
		company				price	ticker
	0	American Express	95	AXP
	1	Cisco				25	CSCO
	2	Walt Disney			85	DIS
	3	Microsoft			41	MSFT
	4	Walmart				78	WMT

Note: all the arrays in a DF should be of the same size,
example,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney']})  /#i.e. company has only 3 values
	print(data)
						 
	O/p:
	ValueError: arrays must all be same length

to print data for a specific key,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	print(data['company'])
	print(data.company)  //same result as above  
	
	o/p:
	0    American Express
	1               Cisco
	2         Walt Disney
	3           Microsoft
	4             Walmart
	Name: company, dtype: object
	
to print a row corresponding to an index,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	print (data.ix[2])       # Print the row corresponding to the given Index
	print (data.ix[2:4])     #range of indices
	
	o/p:
	company    Walt Disney
	price               85
	ticker             DIS
	Name: 2, dtype: object
	
		   company  price ticker
	2  Walt Disney     85    DIS
	3    Microsoft     41   MSFT
	4      Walmart     78    WMT
	
filtering DF based on "key"/"columns":
example,
	data.ix[data.ticker=='DIS']            # Print the row corresponding to the ticker that is 'DIS'
	print(data)

	o/p:
	company	price	ticker
	2	Walt Disney	85	DIS

adding a new column to a DF,
example,
	data = pd.DataFrame({'price':[95, 25, 85, 41, 78],
						 'ticker':['AXP', 'CSCO', 'DIS', 'MSFT', 'WMT'],
						 'company':['American Express', 'Cisco', 'Walt Disney','Microsoft', 'Walmart']})
	data['Year'] = 2014                    # Add additional column Year. Populate value of 2014 in all the rows.
	print(data)
	data['pricesquared'] = data.price**2      # Square all the prices and add another column 'pricesquared'.
	print(data)
	del data['pricesquared']                  # Delete column 'pricesquared'
	print(data)
	data['pricesquared'] = np.NaN             # Create column 'pricesquared' with NaN values
	print(data)
	data['sequence'] = np.arange(2014,2024,2) # Add column 'sequence'												
	print(data)
	
O/p:
	company				price	ticker	Year
0	American Express	95		AXP		2014
1	Cisco				25		CSCO	2014
2	Walt Disney			85		DIS		2014
3	Microsoft			41		MSFT	2014
4	Walmart				78		WMT		2014
#
	company				price	ticker	Year	pricesquared
0	American Express	95		AXP		2014	9025
1	Cisco				25		CSCO	2014	625
2	Walt Disney			85		DIS		2014	7225
3	Microsoft			41		MSFT	2014	1681
4	Walmart				78		WMT		2014	6084
#
	company				price	ticker	Year
0	American Express	95		AXP		2014
1	Cisco				25		CSCO	2014
2	Walt Disney			85		DIS		2014
3	Microsoft			41		MSFT	2014
4	Walmart				78		WMT		2014
#
	company				price	ticker	Year	pricesquared
0	American Express	95		AXP		2014	NaN
1	Cisco				25		CSCO	2014	NaN
2	Walt Disney			85		DIS		2014	NaN
3	Microsoft			41		MSFT	2014	NaN
4	Walmart				78		WMT		2014	NaN
#
	company				price	ticker	Year	pricesquared	sequence
0	American Express	95		AXP		2014	NaN				2014
1	Cisco				25		CSCO	2014	NaN				2016
2	Walt Disney			85		DIS		2014	NaN				2018
3	Microsoft			41		MSFT	2014	NaN				2020
4	Walmart				78		WMT		2014	NaN				2022


Using Numpy functions inside DataFrame Objects:
example,
	import pandas as pd
	import numpy as np
	# Create array of 3*3 dimensionality using standard normally distributed random vales
	dataframe = pd.DataFrame(np.random.randn(3,3),columns=['one','two','three'])  
	print(dataframe)
	print(np.abs(dataframe))                   # Absolute value
	f = lambda x:x.max()-x.min()               # lambda function to get range i.e. max - min.
	print (abs(dataframe).apply(f))            # applies to column (BY-DEFAULT)
	abs(dataframe).apply(f,axis=1)             #axis=1, applies to row
	
	
	o/p:
		one			two			three
	0	-0.057379	0.244387	0.128660
	1	0.342184	1.080002	-0.528302
	2	0.370405	-0.319412	1.427701
	#
		one			two			three
	0	0.057379	0.244387	0.128660
	1	0.342184	1.080002	0.528302
	2	0.370405	0.319412	1.427701
	# column range
	one      0.313026
	two      0.835614
	three    1.299041
	dtype: float64
	#row range
	0    0.187008
	1    0.737818
	2    1.108289
	dtype: float64
	
example-2:
	print(dataframe)
	dataframe.sum()                          # Column wise sum
	dataframe.sum(axis=1)                    # Row wise sum
	dataframe.cumsum()                 		 # Get cumulative sum
	
o/p:
#column-wise
one      0.655210
two      1.004977
three    1.028059
dtype: float64
#row-wise
0    0.315668
1    0.893883
2    1.478694
dtype: float64
#cumlative


	
function to create a series having mean, max and min of a set of DF rows using numpy functions.
example,
	def f(x):
		return pd.Series([np.mean(x), x.max(), x.min()], index=['mean','max','min'])
	print(dataframe)
	print(dataframe.apply(f,axis=1))
	
o/p:
	one       two     three
0 -0.057379  0.244387  0.128660
1  0.342184  1.080002 -0.528302
2  0.370405 -0.319412  1.427701
#
	mean		max			min
0	0.105223	0.244387	-0.057379
1	0.297961	1.080002	-0.528302
2	0.492898	1.427701	-0.319412
	


	





